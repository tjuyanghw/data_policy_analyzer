/*
  Copyright 2019 Kakao Corp.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
 */
apply plugin: "com.android.library"
apply plugin: "kotlin-android"
apply plugin: "kotlin-android-extensions"
apply plugin: "kotlin-kapt"
apply plugin: "jacoco"
apply plugin: "maven-publish"

jacoco {
    toolVersion = "0.8.2"
}

androidExtensions {
    experimental = true
}

task sourcesJar(type: Jar) {
    from android.sourceSets.main.java.srcDirs
    archiveClassifier.set("sources")
}

android {
    compileSdkVersion SdkVersions.compileSdkVersion // 무조건 최신 유지

    defaultConfig {
        minSdkVersion SdkVersions.minSdkVersion
        targetSdkVersion SdkVersions.targetSdkVersion // 무조건 최신 유지
        versionCode SdkVersions.versionCode
        versionName SdkVersions.version

        testInstrumentationRunner "androidx.test.ext.junit.runners.AndroidJunit4"

    }

    buildTypes {
        debug {
            testCoverageEnabled true
            minifyEnabled false
        }
        release {
            minifyEnabled false
//            proguardFiles getDefaultProguardFile("proguard-android.txt"), "proguard-rules.pro"
        }
    }

    testOptions {
        unitTests {
            includeAndroidResources = true
        }
        unitTests.all {
            jacoco {
                includeNoLocationClasses = true
            }
        }
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    tasks.withType(Test) {
        useJUnitPlatform()
    }



    // parallel 빌드를 안하면 ./gradlew test publish dokka zipProject 등 순서대로 실행하면 된다.
    // task 의존성 설정 (testReleaseUnitTest -> assembleRelease, dokka -> zipProject)
    libraryVariants.all { variant ->
        if (variant.buildType.name == "debug") return
        rootProject.getTasksByName("zipProject", false).forEach {
            it.dependsOn(assembleRelease)
        }
        rootProject.getTasksByName("dokka", false).forEach {
            it.mustRunAfter(testReleaseUnitTest) // dokka 문서 생성 전에 unit test 를 돌림
        }
        assembleRelease.dependsOn(testReleaseUnitTest) // release 빌드 전에는 release unit test 를 무조건 돌린다.
    }
}

publishing {
    repositories {
        maven {
            if (SdkVersions.version.endsWith("-SNAPSHOT")) {
                url project.hasProperty("nexusSnapshotRepositoryUrl") ? nexusSnapshotRepositoryUrl : mavenLocal().url
            } else {
                url project.hasProperty("nexusReleaseRepositoryUrl") ? nexusReleaseRepositoryUrl : mavenLocal().url
            }
            if (project.hasProperty("nexusUsername") && project.hasProperty("nexusPassword")) {
                credentials {
                    username nexusUsername
                    password nexusPassword
                }
            }
        }
    }
    android.libraryVariants.all { variant ->
        if (variant.buildType.name == 'debug') return
        version = "${project.android.defaultConfig.versionName}"
        publications {
            "${variant.name}"(MavenPublication) {
                groupId Publish.groupId
                version version
                artifactId "v2-${project.name}"

                artifact(variant.packageLibraryProvider.get().archivePath) {
                    builtBy variant.assembleProvider // assembleRelease 에 의존성 설정
                }
                artifact sourcesJar

                pom.withXml {
                    def dependenciesNode = asNode().appendNode('dependencies')
                    //Iterate over the compile dependencies (we don't want the test ones), adding a <dependency> node for each
                    variant.compileConfiguration.allDependencies.each {
                        def dependencyNode = dependenciesNode.appendNode('dependency')
                        if (it.hasProperty('dependencyProject')) {
                            // kakao sdk modules
                            dependencyNode.appendNode('groupId', Publish.groupId)
                            dependencyNode.appendNode('artifactId', "v2-${it.name}")
                            dependencyNode.appendNode('version', version)
                            dependencyNode.appendNode('type', 'aar')
                        } else {
                            // external dependencies
                            dependencyNode.appendNode('groupId', it.group)
                            dependencyNode.appendNode('artifactId', it.name)
                            dependencyNode.appendNode('version', it.version)
                        }
                    }

                    def licenses = asNode().appendNode('licenses')
                    def license = licenses.appendNode('license')
                    license.appendNode('name', 'The Apache Software License, Version 2.0')
                    license.appendNode('url', 'http://www.apache.org/licenses/LICENSE-2.0.txt')
                    license.appendNode('distribution', 'repo')
                }
            }
        }
    }
}


//task jacocoTestReport(type: JacocoReport, dependsOn: "testDebugUnitTest") {
//    group "Reporting"
//    description "Generate Jacoco coverage reports."
//
//    reports {
//        html.enabled = true
//    }
//
//    def fileFilter = ["**/R.class", "**/R\$*.class", "**/BuildConfig.*", "**/Manifest*.*", "**/*Test*.*", "android/**/*.*"]
//    def execution = fileTree(dir: project.buildDir,
//            includes: ["jacoco/testDebugUnitTest.exec",
//                       "outputs/code_coverage/debugAndroidTest/connected/**/*.ec"])
//
//    afterEvaluate {
//        def javaClasses = fileTree(dir: compileDebugJavaWithJavac.destinationDir, excludes: fileFilter)
//        def kotlinClasses = fileTree(dir: compileDebugKotlin.destinationDir, excludes: fileFilter)
//        classDirectories.setFrom(files(javaClasses, kotlinClasses))
//    }
//    executionData.setFrom(files(execution))
//}