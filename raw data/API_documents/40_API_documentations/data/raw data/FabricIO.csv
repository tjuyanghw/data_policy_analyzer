class_name,class_description,method,method_description,data_type
io.fabric.sdk.android.ActivityLifecycleManager,This is a convenience class that wraps the ActivityLifecycleCallbacks registration. It provides an abstract Callbacks class that reduces required boilerplate code in your callbacks as well as OS Version checks that make it compatible with Android versions less than Ice Cream Sandwich.,registerCallbacks(ActivityLifecycleManager.Callbacks callbacks),N/A,boolean
io.fabric.sdk.android.ActivityLifecycleManager,This is a convenience class that wraps the ActivityLifecycleCallbacks registration. It provides an abstract Callbacks class that reduces required boilerplate code in your callbacks as well as OS Version checks that make it compatible with Android versions less than Ice Cream Sandwich.,resetCallbacks(),Unregisters all previously registered callbacks on the application context.,void
io.fabric.sdk.android.ActivityLifecycleManager.Callbacks,Override the methods corresponding to the activity.,"onActivityCreated(Activity activity,                 Bundle bundle)",N/A,void
io.fabric.sdk.android.ActivityLifecycleManager.Callbacks,Override the methods corresponding to the activity.,onActivityDestroyed(Activity activity),N/A,void
io.fabric.sdk.android.ActivityLifecycleManager.Callbacks,Override the methods corresponding to the activity.,onActivityPaused(Activity activity),N/A,void
io.fabric.sdk.android.ActivityLifecycleManager.Callbacks,Override the methods corresponding to the activity.,onActivityResumed(Activity activity),N/A,void
io.fabric.sdk.android.ActivityLifecycleManager.Callbacks,Override the methods corresponding to the activity.,"onActivitySaveInstanceState(Activity activity,                           Bundle bundle)",N/A,void
io.fabric.sdk.android.ActivityLifecycleManager.Callbacks,Override the methods corresponding to the activity.,onActivityStarted(Activity activity),N/A,void
io.fabric.sdk.android.ActivityLifecycleManager.Callbacks,Override the methods corresponding to the activity.,onActivityStopped(Activity activity),N/A,void
io.fabric.sdk.android.services.concurrency.AsyncTask,"AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers. AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent pacakge such as Executor, ThreadPoolExecutor and FutureTask. An asynchronous task is defined by a computation that runs on a background thread and whose result is published on the UI thread. An asynchronous task is defined by 3 generic types, called Params, Progress and Result, and 4 steps, called onPreExecute, doInBackground, onProgressUpdate and onPostExecute.  Developer Guides For more information about using tasks and threads, read the Processes and Threads developer guide.  Usage AsyncTask must be subclassed to be used. The subclass will override at least one method (doInBackground(Params...)), and most often will override a second one (onPostExecute(Result).) Here is an example of subclassing:  private class DownloadFilesTask extends AsyncTask<URL, Integer, Long> {     protected Long doInBackground(URL... urls) {         int count = urls.length;         long totalSize = 0;         for (int i = 0; i < count; i++) {             totalSize += Downloader.downloadFile(urls[i]);             publishProgress((int) ((i / (float) count) * 100));             // Escape early if cancel() is called             if (isCancelled()) break;         }         return totalSize;     }     protected void onProgressUpdate(Integer... progress) {         setProgressPercent(progress[0]);     }     protected void onPostExecute(Long result) {         showDialog(""Downloaded "" + result + "" bytes"");     } }  Once created, a task is executed very simply:  new DownloadFilesTask().execute(url1, url2, url3);  AsyncTask's generic types The three types used by an asynchronous task are the following:      Params, the type of the parameters sent to the task upon     execution.     Progress, the type of the progress units published during     the background computation.     Result, the type of the result of the background     computation.  Not all types are always used by an asynchronous task. To mark a type as unused, simply use the type Void:  private class MyTask extends AsyncTask<Void, Void, Void> { ... }  The 4 steps When an asynchronous task is executed, the task goes through 4 steps:      onPreExecute(), invoked on the UI thread before the task     is executed. This step is normally used to setup the task, for instance by     showing a progress bar in the user interface.     doInBackground(Params...), invoked on the background thread     immediately after onPreExecute() finishes executing. This step is used     to perform background computation that can take a long time. The parameters     of the asynchronous task are passed to this step. The result of the computation must     be returned by this step and will be passed back to the last step. This step     can also use publishProgress(Progress...) to publish one or more units     of progress. These values are published on the UI thread, in the     onProgressUpdate(Progress...) step.     onProgressUpdate(Progress...), invoked on the UI thread after a     call to publishProgress(Progress...). The timing of the execution is     undefined. This method is used to display any form of progress in the user     interface while the background computation is still executing. For instance,     it can be used to animate a progress bar or show logs in a text field.     onPostExecute(Result), invoked on the UI thread after the background     computation finishes. The result of the background computation is passed to     this step as a parameter.  Cancelling a task A task can be cancelled at any time by invoking cancel(boolean). Invoking this method will cause subsequent calls to isCancelled() to return true. After invoking this method, onCancelled(Object), instead of onPostExecute(Object) will be invoked after doInBackground(Object[]) returns. To ensure that a task is cancelled as quickly as possible, you should always check the return value of isCancelled() periodically from doInBackground(Object[]), if possible (inside a loop for instance.) Threading rules There are a few threading rules that must be followed for this class to work properly:      The AsyncTask class must be loaded on the UI thread. This is done     automatically as of Build.VERSION_CODES.JELLY_BEAN.     The task instance must be created on the UI thread.     execute(Params...) must be invoked on the UI thread.     Do not call onPreExecute(), onPostExecute(Result),     doInBackground(Params...), onProgressUpdate(Progress...) manually.     The task can be executed only once (an exception will be thrown if     a second execution is attempted.)  Memory observability AsyncTask guarantees that all callback calls are synchronized in such a way that the following operations are safe without explicit synchronizations.      Set member fields in the constructor or onPreExecute(), and refer to them     in doInBackground(Params...).     Set member fields in doInBackground(Params...), and refer to them in     onProgressUpdate(Progress...) and onPostExecute(Result).  Order of execution When first introduced, AsyncTasks were executed serially on a single background thread. Starting with Build.VERSION_CODES.DONUT, this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting with Build.VERSION_CODES.HONEYCOMB, tasks are executed on a single thread to avoid common application errors caused by parallel execution. If you truly want parallel execution, you can invoke executeOnExecutor(java.util.concurrent.Executor, Object[]) with THREAD_POOL_EXECUTOR.",cancel(boolean mayInterruptIfRunning),Attempts to cancel execution of this task.,boolean
io.fabric.sdk.android.services.concurrency.AsyncTask,"AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers. AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent pacakge such as Executor, ThreadPoolExecutor and FutureTask. An asynchronous task is defined by a computation that runs on a background thread and whose result is published on the UI thread. An asynchronous task is defined by 3 generic types, called Params, Progress and Result, and 4 steps, called onPreExecute, doInBackground, onProgressUpdate and onPostExecute.  Developer Guides For more information about using tasks and threads, read the Processes and Threads developer guide.  Usage AsyncTask must be subclassed to be used. The subclass will override at least one method (doInBackground(Params...)), and most often will override a second one (onPostExecute(Result).) Here is an example of subclassing:  private class DownloadFilesTask extends AsyncTask<URL, Integer, Long> {     protected Long doInBackground(URL... urls) {         int count = urls.length;         long totalSize = 0;         for (int i = 0; i < count; i++) {             totalSize += Downloader.downloadFile(urls[i]);             publishProgress((int) ((i / (float) count) * 100));             // Escape early if cancel() is called             if (isCancelled()) break;         }         return totalSize;     }     protected void onProgressUpdate(Integer... progress) {         setProgressPercent(progress[0]);     }     protected void onPostExecute(Long result) {         showDialog(""Downloaded "" + result + "" bytes"");     } }  Once created, a task is executed very simply:  new DownloadFilesTask().execute(url1, url2, url3);  AsyncTask's generic types The three types used by an asynchronous task are the following:      Params, the type of the parameters sent to the task upon     execution.     Progress, the type of the progress units published during     the background computation.     Result, the type of the result of the background     computation.  Not all types are always used by an asynchronous task. To mark a type as unused, simply use the type Void:  private class MyTask extends AsyncTask<Void, Void, Void> { ... }  The 4 steps When an asynchronous task is executed, the task goes through 4 steps:      onPreExecute(), invoked on the UI thread before the task     is executed. This step is normally used to setup the task, for instance by     showing a progress bar in the user interface.     doInBackground(Params...), invoked on the background thread     immediately after onPreExecute() finishes executing. This step is used     to perform background computation that can take a long time. The parameters     of the asynchronous task are passed to this step. The result of the computation must     be returned by this step and will be passed back to the last step. This step     can also use publishProgress(Progress...) to publish one or more units     of progress. These values are published on the UI thread, in the     onProgressUpdate(Progress...) step.     onProgressUpdate(Progress...), invoked on the UI thread after a     call to publishProgress(Progress...). The timing of the execution is     undefined. This method is used to display any form of progress in the user     interface while the background computation is still executing. For instance,     it can be used to animate a progress bar or show logs in a text field.     onPostExecute(Result), invoked on the UI thread after the background     computation finishes. The result of the background computation is passed to     this step as a parameter.  Cancelling a task A task can be cancelled at any time by invoking cancel(boolean). Invoking this method will cause subsequent calls to isCancelled() to return true. After invoking this method, onCancelled(Object), instead of onPostExecute(Object) will be invoked after doInBackground(Object[]) returns. To ensure that a task is cancelled as quickly as possible, you should always check the return value of isCancelled() periodically from doInBackground(Object[]), if possible (inside a loop for instance.) Threading rules There are a few threading rules that must be followed for this class to work properly:      The AsyncTask class must be loaded on the UI thread. This is done     automatically as of Build.VERSION_CODES.JELLY_BEAN.     The task instance must be created on the UI thread.     execute(Params...) must be invoked on the UI thread.     Do not call onPreExecute(), onPostExecute(Result),     doInBackground(Params...), onProgressUpdate(Progress...) manually.     The task can be executed only once (an exception will be thrown if     a second execution is attempted.)  Memory observability AsyncTask guarantees that all callback calls are synchronized in such a way that the following operations are safe without explicit synchronizations.      Set member fields in the constructor or onPreExecute(), and refer to them     in doInBackground(Params...).     Set member fields in doInBackground(Params...), and refer to them in     onProgressUpdate(Progress...) and onPostExecute(Result).  Order of execution When first introduced, AsyncTasks were executed serially on a single background thread. Starting with Build.VERSION_CODES.DONUT, this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting with Build.VERSION_CODES.HONEYCOMB, tasks are executed on a single thread to avoid common application errors caused by parallel execution. If you truly want parallel execution, you can invoke executeOnExecutor(java.util.concurrent.Executor, Object[]) with THREAD_POOL_EXECUTOR.",doInBackground(Params... params),Override this method to perform a computation on a background thread.,protected abstract Result
io.fabric.sdk.android.services.concurrency.AsyncTask,"AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers. AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent pacakge such as Executor, ThreadPoolExecutor and FutureTask. An asynchronous task is defined by a computation that runs on a background thread and whose result is published on the UI thread. An asynchronous task is defined by 3 generic types, called Params, Progress and Result, and 4 steps, called onPreExecute, doInBackground, onProgressUpdate and onPostExecute.  Developer Guides For more information about using tasks and threads, read the Processes and Threads developer guide.  Usage AsyncTask must be subclassed to be used. The subclass will override at least one method (doInBackground(Params...)), and most often will override a second one (onPostExecute(Result).) Here is an example of subclassing:  private class DownloadFilesTask extends AsyncTask<URL, Integer, Long> {     protected Long doInBackground(URL... urls) {         int count = urls.length;         long totalSize = 0;         for (int i = 0; i < count; i++) {             totalSize += Downloader.downloadFile(urls[i]);             publishProgress((int) ((i / (float) count) * 100));             // Escape early if cancel() is called             if (isCancelled()) break;         }         return totalSize;     }     protected void onProgressUpdate(Integer... progress) {         setProgressPercent(progress[0]);     }     protected void onPostExecute(Long result) {         showDialog(""Downloaded "" + result + "" bytes"");     } }  Once created, a task is executed very simply:  new DownloadFilesTask().execute(url1, url2, url3);  AsyncTask's generic types The three types used by an asynchronous task are the following:      Params, the type of the parameters sent to the task upon     execution.     Progress, the type of the progress units published during     the background computation.     Result, the type of the result of the background     computation.  Not all types are always used by an asynchronous task. To mark a type as unused, simply use the type Void:  private class MyTask extends AsyncTask<Void, Void, Void> { ... }  The 4 steps When an asynchronous task is executed, the task goes through 4 steps:      onPreExecute(), invoked on the UI thread before the task     is executed. This step is normally used to setup the task, for instance by     showing a progress bar in the user interface.     doInBackground(Params...), invoked on the background thread     immediately after onPreExecute() finishes executing. This step is used     to perform background computation that can take a long time. The parameters     of the asynchronous task are passed to this step. The result of the computation must     be returned by this step and will be passed back to the last step. This step     can also use publishProgress(Progress...) to publish one or more units     of progress. These values are published on the UI thread, in the     onProgressUpdate(Progress...) step.     onProgressUpdate(Progress...), invoked on the UI thread after a     call to publishProgress(Progress...). The timing of the execution is     undefined. This method is used to display any form of progress in the user     interface while the background computation is still executing. For instance,     it can be used to animate a progress bar or show logs in a text field.     onPostExecute(Result), invoked on the UI thread after the background     computation finishes. The result of the background computation is passed to     this step as a parameter.  Cancelling a task A task can be cancelled at any time by invoking cancel(boolean). Invoking this method will cause subsequent calls to isCancelled() to return true. After invoking this method, onCancelled(Object), instead of onPostExecute(Object) will be invoked after doInBackground(Object[]) returns. To ensure that a task is cancelled as quickly as possible, you should always check the return value of isCancelled() periodically from doInBackground(Object[]), if possible (inside a loop for instance.) Threading rules There are a few threading rules that must be followed for this class to work properly:      The AsyncTask class must be loaded on the UI thread. This is done     automatically as of Build.VERSION_CODES.JELLY_BEAN.     The task instance must be created on the UI thread.     execute(Params...) must be invoked on the UI thread.     Do not call onPreExecute(), onPostExecute(Result),     doInBackground(Params...), onProgressUpdate(Progress...) manually.     The task can be executed only once (an exception will be thrown if     a second execution is attempted.)  Memory observability AsyncTask guarantees that all callback calls are synchronized in such a way that the following operations are safe without explicit synchronizations.      Set member fields in the constructor or onPreExecute(), and refer to them     in doInBackground(Params...).     Set member fields in doInBackground(Params...), and refer to them in     onProgressUpdate(Progress...) and onPostExecute(Result).  Order of execution When first introduced, AsyncTasks were executed serially on a single background thread. Starting with Build.VERSION_CODES.DONUT, this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting with Build.VERSION_CODES.HONEYCOMB, tasks are executed on a single thread to avoid common application errors caused by parallel execution. If you truly want parallel execution, you can invoke executeOnExecutor(java.util.concurrent.Executor, Object[]) with THREAD_POOL_EXECUTOR.",execute(Params... params),Executes the task with the specified parameters.,"AsyncTask<Params,Progress,Result>"
io.fabric.sdk.android.services.concurrency.AsyncTask,"AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers. AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent pacakge such as Executor, ThreadPoolExecutor and FutureTask. An asynchronous task is defined by a computation that runs on a background thread and whose result is published on the UI thread. An asynchronous task is defined by 3 generic types, called Params, Progress and Result, and 4 steps, called onPreExecute, doInBackground, onProgressUpdate and onPostExecute.  Developer Guides For more information about using tasks and threads, read the Processes and Threads developer guide.  Usage AsyncTask must be subclassed to be used. The subclass will override at least one method (doInBackground(Params...)), and most often will override a second one (onPostExecute(Result).) Here is an example of subclassing:  private class DownloadFilesTask extends AsyncTask<URL, Integer, Long> {     protected Long doInBackground(URL... urls) {         int count = urls.length;         long totalSize = 0;         for (int i = 0; i < count; i++) {             totalSize += Downloader.downloadFile(urls[i]);             publishProgress((int) ((i / (float) count) * 100));             // Escape early if cancel() is called             if (isCancelled()) break;         }         return totalSize;     }     protected void onProgressUpdate(Integer... progress) {         setProgressPercent(progress[0]);     }     protected void onPostExecute(Long result) {         showDialog(""Downloaded "" + result + "" bytes"");     } }  Once created, a task is executed very simply:  new DownloadFilesTask().execute(url1, url2, url3);  AsyncTask's generic types The three types used by an asynchronous task are the following:      Params, the type of the parameters sent to the task upon     execution.     Progress, the type of the progress units published during     the background computation.     Result, the type of the result of the background     computation.  Not all types are always used by an asynchronous task. To mark a type as unused, simply use the type Void:  private class MyTask extends AsyncTask<Void, Void, Void> { ... }  The 4 steps When an asynchronous task is executed, the task goes through 4 steps:      onPreExecute(), invoked on the UI thread before the task     is executed. This step is normally used to setup the task, for instance by     showing a progress bar in the user interface.     doInBackground(Params...), invoked on the background thread     immediately after onPreExecute() finishes executing. This step is used     to perform background computation that can take a long time. The parameters     of the asynchronous task are passed to this step. The result of the computation must     be returned by this step and will be passed back to the last step. This step     can also use publishProgress(Progress...) to publish one or more units     of progress. These values are published on the UI thread, in the     onProgressUpdate(Progress...) step.     onProgressUpdate(Progress...), invoked on the UI thread after a     call to publishProgress(Progress...). The timing of the execution is     undefined. This method is used to display any form of progress in the user     interface while the background computation is still executing. For instance,     it can be used to animate a progress bar or show logs in a text field.     onPostExecute(Result), invoked on the UI thread after the background     computation finishes. The result of the background computation is passed to     this step as a parameter.  Cancelling a task A task can be cancelled at any time by invoking cancel(boolean). Invoking this method will cause subsequent calls to isCancelled() to return true. After invoking this method, onCancelled(Object), instead of onPostExecute(Object) will be invoked after doInBackground(Object[]) returns. To ensure that a task is cancelled as quickly as possible, you should always check the return value of isCancelled() periodically from doInBackground(Object[]), if possible (inside a loop for instance.) Threading rules There are a few threading rules that must be followed for this class to work properly:      The AsyncTask class must be loaded on the UI thread. This is done     automatically as of Build.VERSION_CODES.JELLY_BEAN.     The task instance must be created on the UI thread.     execute(Params...) must be invoked on the UI thread.     Do not call onPreExecute(), onPostExecute(Result),     doInBackground(Params...), onProgressUpdate(Progress...) manually.     The task can be executed only once (an exception will be thrown if     a second execution is attempted.)  Memory observability AsyncTask guarantees that all callback calls are synchronized in such a way that the following operations are safe without explicit synchronizations.      Set member fields in the constructor or onPreExecute(), and refer to them     in doInBackground(Params...).     Set member fields in doInBackground(Params...), and refer to them in     onProgressUpdate(Progress...) and onPostExecute(Result).  Order of execution When first introduced, AsyncTasks were executed serially on a single background thread. Starting with Build.VERSION_CODES.DONUT, this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting with Build.VERSION_CODES.HONEYCOMB, tasks are executed on a single thread to avoid common application errors caused by parallel execution. If you truly want parallel execution, you can invoke executeOnExecutor(java.util.concurrent.Executor, Object[]) with THREAD_POOL_EXECUTOR.",execute(Runnable runnable),Convenience version of execute(Object...) for use with a simple Runnable object.,static void
io.fabric.sdk.android.services.concurrency.AsyncTask,"AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers. AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent pacakge such as Executor, ThreadPoolExecutor and FutureTask. An asynchronous task is defined by a computation that runs on a background thread and whose result is published on the UI thread. An asynchronous task is defined by 3 generic types, called Params, Progress and Result, and 4 steps, called onPreExecute, doInBackground, onProgressUpdate and onPostExecute.  Developer Guides For more information about using tasks and threads, read the Processes and Threads developer guide.  Usage AsyncTask must be subclassed to be used. The subclass will override at least one method (doInBackground(Params...)), and most often will override a second one (onPostExecute(Result).) Here is an example of subclassing:  private class DownloadFilesTask extends AsyncTask<URL, Integer, Long> {     protected Long doInBackground(URL... urls) {         int count = urls.length;         long totalSize = 0;         for (int i = 0; i < count; i++) {             totalSize += Downloader.downloadFile(urls[i]);             publishProgress((int) ((i / (float) count) * 100));             // Escape early if cancel() is called             if (isCancelled()) break;         }         return totalSize;     }     protected void onProgressUpdate(Integer... progress) {         setProgressPercent(progress[0]);     }     protected void onPostExecute(Long result) {         showDialog(""Downloaded "" + result + "" bytes"");     } }  Once created, a task is executed very simply:  new DownloadFilesTask().execute(url1, url2, url3);  AsyncTask's generic types The three types used by an asynchronous task are the following:      Params, the type of the parameters sent to the task upon     execution.     Progress, the type of the progress units published during     the background computation.     Result, the type of the result of the background     computation.  Not all types are always used by an asynchronous task. To mark a type as unused, simply use the type Void:  private class MyTask extends AsyncTask<Void, Void, Void> { ... }  The 4 steps When an asynchronous task is executed, the task goes through 4 steps:      onPreExecute(), invoked on the UI thread before the task     is executed. This step is normally used to setup the task, for instance by     showing a progress bar in the user interface.     doInBackground(Params...), invoked on the background thread     immediately after onPreExecute() finishes executing. This step is used     to perform background computation that can take a long time. The parameters     of the asynchronous task are passed to this step. The result of the computation must     be returned by this step and will be passed back to the last step. This step     can also use publishProgress(Progress...) to publish one or more units     of progress. These values are published on the UI thread, in the     onProgressUpdate(Progress...) step.     onProgressUpdate(Progress...), invoked on the UI thread after a     call to publishProgress(Progress...). The timing of the execution is     undefined. This method is used to display any form of progress in the user     interface while the background computation is still executing. For instance,     it can be used to animate a progress bar or show logs in a text field.     onPostExecute(Result), invoked on the UI thread after the background     computation finishes. The result of the background computation is passed to     this step as a parameter.  Cancelling a task A task can be cancelled at any time by invoking cancel(boolean). Invoking this method will cause subsequent calls to isCancelled() to return true. After invoking this method, onCancelled(Object), instead of onPostExecute(Object) will be invoked after doInBackground(Object[]) returns. To ensure that a task is cancelled as quickly as possible, you should always check the return value of isCancelled() periodically from doInBackground(Object[]), if possible (inside a loop for instance.) Threading rules There are a few threading rules that must be followed for this class to work properly:      The AsyncTask class must be loaded on the UI thread. This is done     automatically as of Build.VERSION_CODES.JELLY_BEAN.     The task instance must be created on the UI thread.     execute(Params...) must be invoked on the UI thread.     Do not call onPreExecute(), onPostExecute(Result),     doInBackground(Params...), onProgressUpdate(Progress...) manually.     The task can be executed only once (an exception will be thrown if     a second execution is attempted.)  Memory observability AsyncTask guarantees that all callback calls are synchronized in such a way that the following operations are safe without explicit synchronizations.      Set member fields in the constructor or onPreExecute(), and refer to them     in doInBackground(Params...).     Set member fields in doInBackground(Params...), and refer to them in     onProgressUpdate(Progress...) and onPostExecute(Result).  Order of execution When first introduced, AsyncTasks were executed serially on a single background thread. Starting with Build.VERSION_CODES.DONUT, this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting with Build.VERSION_CODES.HONEYCOMB, tasks are executed on a single thread to avoid common application errors caused by parallel execution. If you truly want parallel execution, you can invoke executeOnExecutor(java.util.concurrent.Executor, Object[]) with THREAD_POOL_EXECUTOR.","executeOnExecutor(Executor exec,                 Params... params)",Executes the task with the specified parameters.,"AsyncTask<Params,Progress,Result>"
io.fabric.sdk.android.services.concurrency.AsyncTask,"AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers. AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent pacakge such as Executor, ThreadPoolExecutor and FutureTask. An asynchronous task is defined by a computation that runs on a background thread and whose result is published on the UI thread. An asynchronous task is defined by 3 generic types, called Params, Progress and Result, and 4 steps, called onPreExecute, doInBackground, onProgressUpdate and onPostExecute.  Developer Guides For more information about using tasks and threads, read the Processes and Threads developer guide.  Usage AsyncTask must be subclassed to be used. The subclass will override at least one method (doInBackground(Params...)), and most often will override a second one (onPostExecute(Result).) Here is an example of subclassing:  private class DownloadFilesTask extends AsyncTask<URL, Integer, Long> {     protected Long doInBackground(URL... urls) {         int count = urls.length;         long totalSize = 0;         for (int i = 0; i < count; i++) {             totalSize += Downloader.downloadFile(urls[i]);             publishProgress((int) ((i / (float) count) * 100));             // Escape early if cancel() is called             if (isCancelled()) break;         }         return totalSize;     }     protected void onProgressUpdate(Integer... progress) {         setProgressPercent(progress[0]);     }     protected void onPostExecute(Long result) {         showDialog(""Downloaded "" + result + "" bytes"");     } }  Once created, a task is executed very simply:  new DownloadFilesTask().execute(url1, url2, url3);  AsyncTask's generic types The three types used by an asynchronous task are the following:      Params, the type of the parameters sent to the task upon     execution.     Progress, the type of the progress units published during     the background computation.     Result, the type of the result of the background     computation.  Not all types are always used by an asynchronous task. To mark a type as unused, simply use the type Void:  private class MyTask extends AsyncTask<Void, Void, Void> { ... }  The 4 steps When an asynchronous task is executed, the task goes through 4 steps:      onPreExecute(), invoked on the UI thread before the task     is executed. This step is normally used to setup the task, for instance by     showing a progress bar in the user interface.     doInBackground(Params...), invoked on the background thread     immediately after onPreExecute() finishes executing. This step is used     to perform background computation that can take a long time. The parameters     of the asynchronous task are passed to this step. The result of the computation must     be returned by this step and will be passed back to the last step. This step     can also use publishProgress(Progress...) to publish one or more units     of progress. These values are published on the UI thread, in the     onProgressUpdate(Progress...) step.     onProgressUpdate(Progress...), invoked on the UI thread after a     call to publishProgress(Progress...). The timing of the execution is     undefined. This method is used to display any form of progress in the user     interface while the background computation is still executing. For instance,     it can be used to animate a progress bar or show logs in a text field.     onPostExecute(Result), invoked on the UI thread after the background     computation finishes. The result of the background computation is passed to     this step as a parameter.  Cancelling a task A task can be cancelled at any time by invoking cancel(boolean). Invoking this method will cause subsequent calls to isCancelled() to return true. After invoking this method, onCancelled(Object), instead of onPostExecute(Object) will be invoked after doInBackground(Object[]) returns. To ensure that a task is cancelled as quickly as possible, you should always check the return value of isCancelled() periodically from doInBackground(Object[]), if possible (inside a loop for instance.) Threading rules There are a few threading rules that must be followed for this class to work properly:      The AsyncTask class must be loaded on the UI thread. This is done     automatically as of Build.VERSION_CODES.JELLY_BEAN.     The task instance must be created on the UI thread.     execute(Params...) must be invoked on the UI thread.     Do not call onPreExecute(), onPostExecute(Result),     doInBackground(Params...), onProgressUpdate(Progress...) manually.     The task can be executed only once (an exception will be thrown if     a second execution is attempted.)  Memory observability AsyncTask guarantees that all callback calls are synchronized in such a way that the following operations are safe without explicit synchronizations.      Set member fields in the constructor or onPreExecute(), and refer to them     in doInBackground(Params...).     Set member fields in doInBackground(Params...), and refer to them in     onProgressUpdate(Progress...) and onPostExecute(Result).  Order of execution When first introduced, AsyncTasks were executed serially on a single background thread. Starting with Build.VERSION_CODES.DONUT, this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting with Build.VERSION_CODES.HONEYCOMB, tasks are executed on a single thread to avoid common application errors caused by parallel execution. If you truly want parallel execution, you can invoke executeOnExecutor(java.util.concurrent.Executor, Object[]) with THREAD_POOL_EXECUTOR.",get(),"Waits if necessary for the computation to complete, and then retrieves its result.",Result
io.fabric.sdk.android.services.concurrency.AsyncTask,"AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers. AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent pacakge such as Executor, ThreadPoolExecutor and FutureTask. An asynchronous task is defined by a computation that runs on a background thread and whose result is published on the UI thread. An asynchronous task is defined by 3 generic types, called Params, Progress and Result, and 4 steps, called onPreExecute, doInBackground, onProgressUpdate and onPostExecute.  Developer Guides For more information about using tasks and threads, read the Processes and Threads developer guide.  Usage AsyncTask must be subclassed to be used. The subclass will override at least one method (doInBackground(Params...)), and most often will override a second one (onPostExecute(Result).) Here is an example of subclassing:  private class DownloadFilesTask extends AsyncTask<URL, Integer, Long> {     protected Long doInBackground(URL... urls) {         int count = urls.length;         long totalSize = 0;         for (int i = 0; i < count; i++) {             totalSize += Downloader.downloadFile(urls[i]);             publishProgress((int) ((i / (float) count) * 100));             // Escape early if cancel() is called             if (isCancelled()) break;         }         return totalSize;     }     protected void onProgressUpdate(Integer... progress) {         setProgressPercent(progress[0]);     }     protected void onPostExecute(Long result) {         showDialog(""Downloaded "" + result + "" bytes"");     } }  Once created, a task is executed very simply:  new DownloadFilesTask().execute(url1, url2, url3);  AsyncTask's generic types The three types used by an asynchronous task are the following:      Params, the type of the parameters sent to the task upon     execution.     Progress, the type of the progress units published during     the background computation.     Result, the type of the result of the background     computation.  Not all types are always used by an asynchronous task. To mark a type as unused, simply use the type Void:  private class MyTask extends AsyncTask<Void, Void, Void> { ... }  The 4 steps When an asynchronous task is executed, the task goes through 4 steps:      onPreExecute(), invoked on the UI thread before the task     is executed. This step is normally used to setup the task, for instance by     showing a progress bar in the user interface.     doInBackground(Params...), invoked on the background thread     immediately after onPreExecute() finishes executing. This step is used     to perform background computation that can take a long time. The parameters     of the asynchronous task are passed to this step. The result of the computation must     be returned by this step and will be passed back to the last step. This step     can also use publishProgress(Progress...) to publish one or more units     of progress. These values are published on the UI thread, in the     onProgressUpdate(Progress...) step.     onProgressUpdate(Progress...), invoked on the UI thread after a     call to publishProgress(Progress...). The timing of the execution is     undefined. This method is used to display any form of progress in the user     interface while the background computation is still executing. For instance,     it can be used to animate a progress bar or show logs in a text field.     onPostExecute(Result), invoked on the UI thread after the background     computation finishes. The result of the background computation is passed to     this step as a parameter.  Cancelling a task A task can be cancelled at any time by invoking cancel(boolean). Invoking this method will cause subsequent calls to isCancelled() to return true. After invoking this method, onCancelled(Object), instead of onPostExecute(Object) will be invoked after doInBackground(Object[]) returns. To ensure that a task is cancelled as quickly as possible, you should always check the return value of isCancelled() periodically from doInBackground(Object[]), if possible (inside a loop for instance.) Threading rules There are a few threading rules that must be followed for this class to work properly:      The AsyncTask class must be loaded on the UI thread. This is done     automatically as of Build.VERSION_CODES.JELLY_BEAN.     The task instance must be created on the UI thread.     execute(Params...) must be invoked on the UI thread.     Do not call onPreExecute(), onPostExecute(Result),     doInBackground(Params...), onProgressUpdate(Progress...) manually.     The task can be executed only once (an exception will be thrown if     a second execution is attempted.)  Memory observability AsyncTask guarantees that all callback calls are synchronized in such a way that the following operations are safe without explicit synchronizations.      Set member fields in the constructor or onPreExecute(), and refer to them     in doInBackground(Params...).     Set member fields in doInBackground(Params...), and refer to them in     onProgressUpdate(Progress...) and onPostExecute(Result).  Order of execution When first introduced, AsyncTasks were executed serially on a single background thread. Starting with Build.VERSION_CODES.DONUT, this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting with Build.VERSION_CODES.HONEYCOMB, tasks are executed on a single thread to avoid common application errors caused by parallel execution. If you truly want parallel execution, you can invoke executeOnExecutor(java.util.concurrent.Executor, Object[]) with THREAD_POOL_EXECUTOR.","get(long timeout,   TimeUnit unit)","Waits if necessary for at most the given time for the computation to complete, and then retrieves its result.",Result
io.fabric.sdk.android.services.concurrency.AsyncTask,"AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers. AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent pacakge such as Executor, ThreadPoolExecutor and FutureTask. An asynchronous task is defined by a computation that runs on a background thread and whose result is published on the UI thread. An asynchronous task is defined by 3 generic types, called Params, Progress and Result, and 4 steps, called onPreExecute, doInBackground, onProgressUpdate and onPostExecute.  Developer Guides For more information about using tasks and threads, read the Processes and Threads developer guide.  Usage AsyncTask must be subclassed to be used. The subclass will override at least one method (doInBackground(Params...)), and most often will override a second one (onPostExecute(Result).) Here is an example of subclassing:  private class DownloadFilesTask extends AsyncTask<URL, Integer, Long> {     protected Long doInBackground(URL... urls) {         int count = urls.length;         long totalSize = 0;         for (int i = 0; i < count; i++) {             totalSize += Downloader.downloadFile(urls[i]);             publishProgress((int) ((i / (float) count) * 100));             // Escape early if cancel() is called             if (isCancelled()) break;         }         return totalSize;     }     protected void onProgressUpdate(Integer... progress) {         setProgressPercent(progress[0]);     }     protected void onPostExecute(Long result) {         showDialog(""Downloaded "" + result + "" bytes"");     } }  Once created, a task is executed very simply:  new DownloadFilesTask().execute(url1, url2, url3);  AsyncTask's generic types The three types used by an asynchronous task are the following:      Params, the type of the parameters sent to the task upon     execution.     Progress, the type of the progress units published during     the background computation.     Result, the type of the result of the background     computation.  Not all types are always used by an asynchronous task. To mark a type as unused, simply use the type Void:  private class MyTask extends AsyncTask<Void, Void, Void> { ... }  The 4 steps When an asynchronous task is executed, the task goes through 4 steps:      onPreExecute(), invoked on the UI thread before the task     is executed. This step is normally used to setup the task, for instance by     showing a progress bar in the user interface.     doInBackground(Params...), invoked on the background thread     immediately after onPreExecute() finishes executing. This step is used     to perform background computation that can take a long time. The parameters     of the asynchronous task are passed to this step. The result of the computation must     be returned by this step and will be passed back to the last step. This step     can also use publishProgress(Progress...) to publish one or more units     of progress. These values are published on the UI thread, in the     onProgressUpdate(Progress...) step.     onProgressUpdate(Progress...), invoked on the UI thread after a     call to publishProgress(Progress...). The timing of the execution is     undefined. This method is used to display any form of progress in the user     interface while the background computation is still executing. For instance,     it can be used to animate a progress bar or show logs in a text field.     onPostExecute(Result), invoked on the UI thread after the background     computation finishes. The result of the background computation is passed to     this step as a parameter.  Cancelling a task A task can be cancelled at any time by invoking cancel(boolean). Invoking this method will cause subsequent calls to isCancelled() to return true. After invoking this method, onCancelled(Object), instead of onPostExecute(Object) will be invoked after doInBackground(Object[]) returns. To ensure that a task is cancelled as quickly as possible, you should always check the return value of isCancelled() periodically from doInBackground(Object[]), if possible (inside a loop for instance.) Threading rules There are a few threading rules that must be followed for this class to work properly:      The AsyncTask class must be loaded on the UI thread. This is done     automatically as of Build.VERSION_CODES.JELLY_BEAN.     The task instance must be created on the UI thread.     execute(Params...) must be invoked on the UI thread.     Do not call onPreExecute(), onPostExecute(Result),     doInBackground(Params...), onProgressUpdate(Progress...) manually.     The task can be executed only once (an exception will be thrown if     a second execution is attempted.)  Memory observability AsyncTask guarantees that all callback calls are synchronized in such a way that the following operations are safe without explicit synchronizations.      Set member fields in the constructor or onPreExecute(), and refer to them     in doInBackground(Params...).     Set member fields in doInBackground(Params...), and refer to them in     onProgressUpdate(Progress...) and onPostExecute(Result).  Order of execution When first introduced, AsyncTasks were executed serially on a single background thread. Starting with Build.VERSION_CODES.DONUT, this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting with Build.VERSION_CODES.HONEYCOMB, tasks are executed on a single thread to avoid common application errors caused by parallel execution. If you truly want parallel execution, you can invoke executeOnExecutor(java.util.concurrent.Executor, Object[]) with THREAD_POOL_EXECUTOR.",getStatus(),Returns the current status of this task.,AsyncTask.Status
io.fabric.sdk.android.services.concurrency.AsyncTask,"AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers. AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent pacakge such as Executor, ThreadPoolExecutor and FutureTask. An asynchronous task is defined by a computation that runs on a background thread and whose result is published on the UI thread. An asynchronous task is defined by 3 generic types, called Params, Progress and Result, and 4 steps, called onPreExecute, doInBackground, onProgressUpdate and onPostExecute.  Developer Guides For more information about using tasks and threads, read the Processes and Threads developer guide.  Usage AsyncTask must be subclassed to be used. The subclass will override at least one method (doInBackground(Params...)), and most often will override a second one (onPostExecute(Result).) Here is an example of subclassing:  private class DownloadFilesTask extends AsyncTask<URL, Integer, Long> {     protected Long doInBackground(URL... urls) {         int count = urls.length;         long totalSize = 0;         for (int i = 0; i < count; i++) {             totalSize += Downloader.downloadFile(urls[i]);             publishProgress((int) ((i / (float) count) * 100));             // Escape early if cancel() is called             if (isCancelled()) break;         }         return totalSize;     }     protected void onProgressUpdate(Integer... progress) {         setProgressPercent(progress[0]);     }     protected void onPostExecute(Long result) {         showDialog(""Downloaded "" + result + "" bytes"");     } }  Once created, a task is executed very simply:  new DownloadFilesTask().execute(url1, url2, url3);  AsyncTask's generic types The three types used by an asynchronous task are the following:      Params, the type of the parameters sent to the task upon     execution.     Progress, the type of the progress units published during     the background computation.     Result, the type of the result of the background     computation.  Not all types are always used by an asynchronous task. To mark a type as unused, simply use the type Void:  private class MyTask extends AsyncTask<Void, Void, Void> { ... }  The 4 steps When an asynchronous task is executed, the task goes through 4 steps:      onPreExecute(), invoked on the UI thread before the task     is executed. This step is normally used to setup the task, for instance by     showing a progress bar in the user interface.     doInBackground(Params...), invoked on the background thread     immediately after onPreExecute() finishes executing. This step is used     to perform background computation that can take a long time. The parameters     of the asynchronous task are passed to this step. The result of the computation must     be returned by this step and will be passed back to the last step. This step     can also use publishProgress(Progress...) to publish one or more units     of progress. These values are published on the UI thread, in the     onProgressUpdate(Progress...) step.     onProgressUpdate(Progress...), invoked on the UI thread after a     call to publishProgress(Progress...). The timing of the execution is     undefined. This method is used to display any form of progress in the user     interface while the background computation is still executing. For instance,     it can be used to animate a progress bar or show logs in a text field.     onPostExecute(Result), invoked on the UI thread after the background     computation finishes. The result of the background computation is passed to     this step as a parameter.  Cancelling a task A task can be cancelled at any time by invoking cancel(boolean). Invoking this method will cause subsequent calls to isCancelled() to return true. After invoking this method, onCancelled(Object), instead of onPostExecute(Object) will be invoked after doInBackground(Object[]) returns. To ensure that a task is cancelled as quickly as possible, you should always check the return value of isCancelled() periodically from doInBackground(Object[]), if possible (inside a loop for instance.) Threading rules There are a few threading rules that must be followed for this class to work properly:      The AsyncTask class must be loaded on the UI thread. This is done     automatically as of Build.VERSION_CODES.JELLY_BEAN.     The task instance must be created on the UI thread.     execute(Params...) must be invoked on the UI thread.     Do not call onPreExecute(), onPostExecute(Result),     doInBackground(Params...), onProgressUpdate(Progress...) manually.     The task can be executed only once (an exception will be thrown if     a second execution is attempted.)  Memory observability AsyncTask guarantees that all callback calls are synchronized in such a way that the following operations are safe without explicit synchronizations.      Set member fields in the constructor or onPreExecute(), and refer to them     in doInBackground(Params...).     Set member fields in doInBackground(Params...), and refer to them in     onProgressUpdate(Progress...) and onPostExecute(Result).  Order of execution When first introduced, AsyncTasks were executed serially on a single background thread. Starting with Build.VERSION_CODES.DONUT, this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting with Build.VERSION_CODES.HONEYCOMB, tasks are executed on a single thread to avoid common application errors caused by parallel execution. If you truly want parallel execution, you can invoke executeOnExecutor(java.util.concurrent.Executor, Object[]) with THREAD_POOL_EXECUTOR.",init(),N/A,static void
io.fabric.sdk.android.services.concurrency.AsyncTask,"AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers. AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent pacakge such as Executor, ThreadPoolExecutor and FutureTask. An asynchronous task is defined by a computation that runs on a background thread and whose result is published on the UI thread. An asynchronous task is defined by 3 generic types, called Params, Progress and Result, and 4 steps, called onPreExecute, doInBackground, onProgressUpdate and onPostExecute.  Developer Guides For more information about using tasks and threads, read the Processes and Threads developer guide.  Usage AsyncTask must be subclassed to be used. The subclass will override at least one method (doInBackground(Params...)), and most often will override a second one (onPostExecute(Result).) Here is an example of subclassing:  private class DownloadFilesTask extends AsyncTask<URL, Integer, Long> {     protected Long doInBackground(URL... urls) {         int count = urls.length;         long totalSize = 0;         for (int i = 0; i < count; i++) {             totalSize += Downloader.downloadFile(urls[i]);             publishProgress((int) ((i / (float) count) * 100));             // Escape early if cancel() is called             if (isCancelled()) break;         }         return totalSize;     }     protected void onProgressUpdate(Integer... progress) {         setProgressPercent(progress[0]);     }     protected void onPostExecute(Long result) {         showDialog(""Downloaded "" + result + "" bytes"");     } }  Once created, a task is executed very simply:  new DownloadFilesTask().execute(url1, url2, url3);  AsyncTask's generic types The three types used by an asynchronous task are the following:      Params, the type of the parameters sent to the task upon     execution.     Progress, the type of the progress units published during     the background computation.     Result, the type of the result of the background     computation.  Not all types are always used by an asynchronous task. To mark a type as unused, simply use the type Void:  private class MyTask extends AsyncTask<Void, Void, Void> { ... }  The 4 steps When an asynchronous task is executed, the task goes through 4 steps:      onPreExecute(), invoked on the UI thread before the task     is executed. This step is normally used to setup the task, for instance by     showing a progress bar in the user interface.     doInBackground(Params...), invoked on the background thread     immediately after onPreExecute() finishes executing. This step is used     to perform background computation that can take a long time. The parameters     of the asynchronous task are passed to this step. The result of the computation must     be returned by this step and will be passed back to the last step. This step     can also use publishProgress(Progress...) to publish one or more units     of progress. These values are published on the UI thread, in the     onProgressUpdate(Progress...) step.     onProgressUpdate(Progress...), invoked on the UI thread after a     call to publishProgress(Progress...). The timing of the execution is     undefined. This method is used to display any form of progress in the user     interface while the background computation is still executing. For instance,     it can be used to animate a progress bar or show logs in a text field.     onPostExecute(Result), invoked on the UI thread after the background     computation finishes. The result of the background computation is passed to     this step as a parameter.  Cancelling a task A task can be cancelled at any time by invoking cancel(boolean). Invoking this method will cause subsequent calls to isCancelled() to return true. After invoking this method, onCancelled(Object), instead of onPostExecute(Object) will be invoked after doInBackground(Object[]) returns. To ensure that a task is cancelled as quickly as possible, you should always check the return value of isCancelled() periodically from doInBackground(Object[]), if possible (inside a loop for instance.) Threading rules There are a few threading rules that must be followed for this class to work properly:      The AsyncTask class must be loaded on the UI thread. This is done     automatically as of Build.VERSION_CODES.JELLY_BEAN.     The task instance must be created on the UI thread.     execute(Params...) must be invoked on the UI thread.     Do not call onPreExecute(), onPostExecute(Result),     doInBackground(Params...), onProgressUpdate(Progress...) manually.     The task can be executed only once (an exception will be thrown if     a second execution is attempted.)  Memory observability AsyncTask guarantees that all callback calls are synchronized in such a way that the following operations are safe without explicit synchronizations.      Set member fields in the constructor or onPreExecute(), and refer to them     in doInBackground(Params...).     Set member fields in doInBackground(Params...), and refer to them in     onProgressUpdate(Progress...) and onPostExecute(Result).  Order of execution When first introduced, AsyncTasks were executed serially on a single background thread. Starting with Build.VERSION_CODES.DONUT, this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting with Build.VERSION_CODES.HONEYCOMB, tasks are executed on a single thread to avoid common application errors caused by parallel execution. If you truly want parallel execution, you can invoke executeOnExecutor(java.util.concurrent.Executor, Object[]) with THREAD_POOL_EXECUTOR.",isCancelled(),Returns true if this task was cancelled before it completed normally.,boolean
io.fabric.sdk.android.services.concurrency.AsyncTask,"AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers. AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent pacakge such as Executor, ThreadPoolExecutor and FutureTask. An asynchronous task is defined by a computation that runs on a background thread and whose result is published on the UI thread. An asynchronous task is defined by 3 generic types, called Params, Progress and Result, and 4 steps, called onPreExecute, doInBackground, onProgressUpdate and onPostExecute.  Developer Guides For more information about using tasks and threads, read the Processes and Threads developer guide.  Usage AsyncTask must be subclassed to be used. The subclass will override at least one method (doInBackground(Params...)), and most often will override a second one (onPostExecute(Result).) Here is an example of subclassing:  private class DownloadFilesTask extends AsyncTask<URL, Integer, Long> {     protected Long doInBackground(URL... urls) {         int count = urls.length;         long totalSize = 0;         for (int i = 0; i < count; i++) {             totalSize += Downloader.downloadFile(urls[i]);             publishProgress((int) ((i / (float) count) * 100));             // Escape early if cancel() is called             if (isCancelled()) break;         }         return totalSize;     }     protected void onProgressUpdate(Integer... progress) {         setProgressPercent(progress[0]);     }     protected void onPostExecute(Long result) {         showDialog(""Downloaded "" + result + "" bytes"");     } }  Once created, a task is executed very simply:  new DownloadFilesTask().execute(url1, url2, url3);  AsyncTask's generic types The three types used by an asynchronous task are the following:      Params, the type of the parameters sent to the task upon     execution.     Progress, the type of the progress units published during     the background computation.     Result, the type of the result of the background     computation.  Not all types are always used by an asynchronous task. To mark a type as unused, simply use the type Void:  private class MyTask extends AsyncTask<Void, Void, Void> { ... }  The 4 steps When an asynchronous task is executed, the task goes through 4 steps:      onPreExecute(), invoked on the UI thread before the task     is executed. This step is normally used to setup the task, for instance by     showing a progress bar in the user interface.     doInBackground(Params...), invoked on the background thread     immediately after onPreExecute() finishes executing. This step is used     to perform background computation that can take a long time. The parameters     of the asynchronous task are passed to this step. The result of the computation must     be returned by this step and will be passed back to the last step. This step     can also use publishProgress(Progress...) to publish one or more units     of progress. These values are published on the UI thread, in the     onProgressUpdate(Progress...) step.     onProgressUpdate(Progress...), invoked on the UI thread after a     call to publishProgress(Progress...). The timing of the execution is     undefined. This method is used to display any form of progress in the user     interface while the background computation is still executing. For instance,     it can be used to animate a progress bar or show logs in a text field.     onPostExecute(Result), invoked on the UI thread after the background     computation finishes. The result of the background computation is passed to     this step as a parameter.  Cancelling a task A task can be cancelled at any time by invoking cancel(boolean). Invoking this method will cause subsequent calls to isCancelled() to return true. After invoking this method, onCancelled(Object), instead of onPostExecute(Object) will be invoked after doInBackground(Object[]) returns. To ensure that a task is cancelled as quickly as possible, you should always check the return value of isCancelled() periodically from doInBackground(Object[]), if possible (inside a loop for instance.) Threading rules There are a few threading rules that must be followed for this class to work properly:      The AsyncTask class must be loaded on the UI thread. This is done     automatically as of Build.VERSION_CODES.JELLY_BEAN.     The task instance must be created on the UI thread.     execute(Params...) must be invoked on the UI thread.     Do not call onPreExecute(), onPostExecute(Result),     doInBackground(Params...), onProgressUpdate(Progress...) manually.     The task can be executed only once (an exception will be thrown if     a second execution is attempted.)  Memory observability AsyncTask guarantees that all callback calls are synchronized in such a way that the following operations are safe without explicit synchronizations.      Set member fields in the constructor or onPreExecute(), and refer to them     in doInBackground(Params...).     Set member fields in doInBackground(Params...), and refer to them in     onProgressUpdate(Progress...) and onPostExecute(Result).  Order of execution When first introduced, AsyncTasks were executed serially on a single background thread. Starting with Build.VERSION_CODES.DONUT, this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting with Build.VERSION_CODES.HONEYCOMB, tasks are executed on a single thread to avoid common application errors caused by parallel execution. If you truly want parallel execution, you can invoke executeOnExecutor(java.util.concurrent.Executor, Object[]) with THREAD_POOL_EXECUTOR.",onCancelled(),Applications should preferably override onCancelled(Object).,protected void
io.fabric.sdk.android.services.concurrency.AsyncTask,"AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers. AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent pacakge such as Executor, ThreadPoolExecutor and FutureTask. An asynchronous task is defined by a computation that runs on a background thread and whose result is published on the UI thread. An asynchronous task is defined by 3 generic types, called Params, Progress and Result, and 4 steps, called onPreExecute, doInBackground, onProgressUpdate and onPostExecute.  Developer Guides For more information about using tasks and threads, read the Processes and Threads developer guide.  Usage AsyncTask must be subclassed to be used. The subclass will override at least one method (doInBackground(Params...)), and most often will override a second one (onPostExecute(Result).) Here is an example of subclassing:  private class DownloadFilesTask extends AsyncTask<URL, Integer, Long> {     protected Long doInBackground(URL... urls) {         int count = urls.length;         long totalSize = 0;         for (int i = 0; i < count; i++) {             totalSize += Downloader.downloadFile(urls[i]);             publishProgress((int) ((i / (float) count) * 100));             // Escape early if cancel() is called             if (isCancelled()) break;         }         return totalSize;     }     protected void onProgressUpdate(Integer... progress) {         setProgressPercent(progress[0]);     }     protected void onPostExecute(Long result) {         showDialog(""Downloaded "" + result + "" bytes"");     } }  Once created, a task is executed very simply:  new DownloadFilesTask().execute(url1, url2, url3);  AsyncTask's generic types The three types used by an asynchronous task are the following:      Params, the type of the parameters sent to the task upon     execution.     Progress, the type of the progress units published during     the background computation.     Result, the type of the result of the background     computation.  Not all types are always used by an asynchronous task. To mark a type as unused, simply use the type Void:  private class MyTask extends AsyncTask<Void, Void, Void> { ... }  The 4 steps When an asynchronous task is executed, the task goes through 4 steps:      onPreExecute(), invoked on the UI thread before the task     is executed. This step is normally used to setup the task, for instance by     showing a progress bar in the user interface.     doInBackground(Params...), invoked on the background thread     immediately after onPreExecute() finishes executing. This step is used     to perform background computation that can take a long time. The parameters     of the asynchronous task are passed to this step. The result of the computation must     be returned by this step and will be passed back to the last step. This step     can also use publishProgress(Progress...) to publish one or more units     of progress. These values are published on the UI thread, in the     onProgressUpdate(Progress...) step.     onProgressUpdate(Progress...), invoked on the UI thread after a     call to publishProgress(Progress...). The timing of the execution is     undefined. This method is used to display any form of progress in the user     interface while the background computation is still executing. For instance,     it can be used to animate a progress bar or show logs in a text field.     onPostExecute(Result), invoked on the UI thread after the background     computation finishes. The result of the background computation is passed to     this step as a parameter.  Cancelling a task A task can be cancelled at any time by invoking cancel(boolean). Invoking this method will cause subsequent calls to isCancelled() to return true. After invoking this method, onCancelled(Object), instead of onPostExecute(Object) will be invoked after doInBackground(Object[]) returns. To ensure that a task is cancelled as quickly as possible, you should always check the return value of isCancelled() periodically from doInBackground(Object[]), if possible (inside a loop for instance.) Threading rules There are a few threading rules that must be followed for this class to work properly:      The AsyncTask class must be loaded on the UI thread. This is done     automatically as of Build.VERSION_CODES.JELLY_BEAN.     The task instance must be created on the UI thread.     execute(Params...) must be invoked on the UI thread.     Do not call onPreExecute(), onPostExecute(Result),     doInBackground(Params...), onProgressUpdate(Progress...) manually.     The task can be executed only once (an exception will be thrown if     a second execution is attempted.)  Memory observability AsyncTask guarantees that all callback calls are synchronized in such a way that the following operations are safe without explicit synchronizations.      Set member fields in the constructor or onPreExecute(), and refer to them     in doInBackground(Params...).     Set member fields in doInBackground(Params...), and refer to them in     onProgressUpdate(Progress...) and onPostExecute(Result).  Order of execution When first introduced, AsyncTasks were executed serially on a single background thread. Starting with Build.VERSION_CODES.DONUT, this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting with Build.VERSION_CODES.HONEYCOMB, tasks are executed on a single thread to avoid common application errors caused by parallel execution. If you truly want parallel execution, you can invoke executeOnExecutor(java.util.concurrent.Executor, Object[]) with THREAD_POOL_EXECUTOR.",onCancelled(Result result),Runs on the UI thread after cancel(boolean) is invoked and doInBackground(Object[]) has finished.,protected void
io.fabric.sdk.android.services.concurrency.AsyncTask,"AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers. AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent pacakge such as Executor, ThreadPoolExecutor and FutureTask. An asynchronous task is defined by a computation that runs on a background thread and whose result is published on the UI thread. An asynchronous task is defined by 3 generic types, called Params, Progress and Result, and 4 steps, called onPreExecute, doInBackground, onProgressUpdate and onPostExecute.  Developer Guides For more information about using tasks and threads, read the Processes and Threads developer guide.  Usage AsyncTask must be subclassed to be used. The subclass will override at least one method (doInBackground(Params...)), and most often will override a second one (onPostExecute(Result).) Here is an example of subclassing:  private class DownloadFilesTask extends AsyncTask<URL, Integer, Long> {     protected Long doInBackground(URL... urls) {         int count = urls.length;         long totalSize = 0;         for (int i = 0; i < count; i++) {             totalSize += Downloader.downloadFile(urls[i]);             publishProgress((int) ((i / (float) count) * 100));             // Escape early if cancel() is called             if (isCancelled()) break;         }         return totalSize;     }     protected void onProgressUpdate(Integer... progress) {         setProgressPercent(progress[0]);     }     protected void onPostExecute(Long result) {         showDialog(""Downloaded "" + result + "" bytes"");     } }  Once created, a task is executed very simply:  new DownloadFilesTask().execute(url1, url2, url3);  AsyncTask's generic types The three types used by an asynchronous task are the following:      Params, the type of the parameters sent to the task upon     execution.     Progress, the type of the progress units published during     the background computation.     Result, the type of the result of the background     computation.  Not all types are always used by an asynchronous task. To mark a type as unused, simply use the type Void:  private class MyTask extends AsyncTask<Void, Void, Void> { ... }  The 4 steps When an asynchronous task is executed, the task goes through 4 steps:      onPreExecute(), invoked on the UI thread before the task     is executed. This step is normally used to setup the task, for instance by     showing a progress bar in the user interface.     doInBackground(Params...), invoked on the background thread     immediately after onPreExecute() finishes executing. This step is used     to perform background computation that can take a long time. The parameters     of the asynchronous task are passed to this step. The result of the computation must     be returned by this step and will be passed back to the last step. This step     can also use publishProgress(Progress...) to publish one or more units     of progress. These values are published on the UI thread, in the     onProgressUpdate(Progress...) step.     onProgressUpdate(Progress...), invoked on the UI thread after a     call to publishProgress(Progress...). The timing of the execution is     undefined. This method is used to display any form of progress in the user     interface while the background computation is still executing. For instance,     it can be used to animate a progress bar or show logs in a text field.     onPostExecute(Result), invoked on the UI thread after the background     computation finishes. The result of the background computation is passed to     this step as a parameter.  Cancelling a task A task can be cancelled at any time by invoking cancel(boolean). Invoking this method will cause subsequent calls to isCancelled() to return true. After invoking this method, onCancelled(Object), instead of onPostExecute(Object) will be invoked after doInBackground(Object[]) returns. To ensure that a task is cancelled as quickly as possible, you should always check the return value of isCancelled() periodically from doInBackground(Object[]), if possible (inside a loop for instance.) Threading rules There are a few threading rules that must be followed for this class to work properly:      The AsyncTask class must be loaded on the UI thread. This is done     automatically as of Build.VERSION_CODES.JELLY_BEAN.     The task instance must be created on the UI thread.     execute(Params...) must be invoked on the UI thread.     Do not call onPreExecute(), onPostExecute(Result),     doInBackground(Params...), onProgressUpdate(Progress...) manually.     The task can be executed only once (an exception will be thrown if     a second execution is attempted.)  Memory observability AsyncTask guarantees that all callback calls are synchronized in such a way that the following operations are safe without explicit synchronizations.      Set member fields in the constructor or onPreExecute(), and refer to them     in doInBackground(Params...).     Set member fields in doInBackground(Params...), and refer to them in     onProgressUpdate(Progress...) and onPostExecute(Result).  Order of execution When first introduced, AsyncTasks were executed serially on a single background thread. Starting with Build.VERSION_CODES.DONUT, this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting with Build.VERSION_CODES.HONEYCOMB, tasks are executed on a single thread to avoid common application errors caused by parallel execution. If you truly want parallel execution, you can invoke executeOnExecutor(java.util.concurrent.Executor, Object[]) with THREAD_POOL_EXECUTOR.",onPostExecute(Result result),Runs on the UI thread after doInBackground(Params...).,protected void
io.fabric.sdk.android.services.concurrency.AsyncTask,"AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers. AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent pacakge such as Executor, ThreadPoolExecutor and FutureTask. An asynchronous task is defined by a computation that runs on a background thread and whose result is published on the UI thread. An asynchronous task is defined by 3 generic types, called Params, Progress and Result, and 4 steps, called onPreExecute, doInBackground, onProgressUpdate and onPostExecute.  Developer Guides For more information about using tasks and threads, read the Processes and Threads developer guide.  Usage AsyncTask must be subclassed to be used. The subclass will override at least one method (doInBackground(Params...)), and most often will override a second one (onPostExecute(Result).) Here is an example of subclassing:  private class DownloadFilesTask extends AsyncTask<URL, Integer, Long> {     protected Long doInBackground(URL... urls) {         int count = urls.length;         long totalSize = 0;         for (int i = 0; i < count; i++) {             totalSize += Downloader.downloadFile(urls[i]);             publishProgress((int) ((i / (float) count) * 100));             // Escape early if cancel() is called             if (isCancelled()) break;         }         return totalSize;     }     protected void onProgressUpdate(Integer... progress) {         setProgressPercent(progress[0]);     }     protected void onPostExecute(Long result) {         showDialog(""Downloaded "" + result + "" bytes"");     } }  Once created, a task is executed very simply:  new DownloadFilesTask().execute(url1, url2, url3);  AsyncTask's generic types The three types used by an asynchronous task are the following:      Params, the type of the parameters sent to the task upon     execution.     Progress, the type of the progress units published during     the background computation.     Result, the type of the result of the background     computation.  Not all types are always used by an asynchronous task. To mark a type as unused, simply use the type Void:  private class MyTask extends AsyncTask<Void, Void, Void> { ... }  The 4 steps When an asynchronous task is executed, the task goes through 4 steps:      onPreExecute(), invoked on the UI thread before the task     is executed. This step is normally used to setup the task, for instance by     showing a progress bar in the user interface.     doInBackground(Params...), invoked on the background thread     immediately after onPreExecute() finishes executing. This step is used     to perform background computation that can take a long time. The parameters     of the asynchronous task are passed to this step. The result of the computation must     be returned by this step and will be passed back to the last step. This step     can also use publishProgress(Progress...) to publish one or more units     of progress. These values are published on the UI thread, in the     onProgressUpdate(Progress...) step.     onProgressUpdate(Progress...), invoked on the UI thread after a     call to publishProgress(Progress...). The timing of the execution is     undefined. This method is used to display any form of progress in the user     interface while the background computation is still executing. For instance,     it can be used to animate a progress bar or show logs in a text field.     onPostExecute(Result), invoked on the UI thread after the background     computation finishes. The result of the background computation is passed to     this step as a parameter.  Cancelling a task A task can be cancelled at any time by invoking cancel(boolean). Invoking this method will cause subsequent calls to isCancelled() to return true. After invoking this method, onCancelled(Object), instead of onPostExecute(Object) will be invoked after doInBackground(Object[]) returns. To ensure that a task is cancelled as quickly as possible, you should always check the return value of isCancelled() periodically from doInBackground(Object[]), if possible (inside a loop for instance.) Threading rules There are a few threading rules that must be followed for this class to work properly:      The AsyncTask class must be loaded on the UI thread. This is done     automatically as of Build.VERSION_CODES.JELLY_BEAN.     The task instance must be created on the UI thread.     execute(Params...) must be invoked on the UI thread.     Do not call onPreExecute(), onPostExecute(Result),     doInBackground(Params...), onProgressUpdate(Progress...) manually.     The task can be executed only once (an exception will be thrown if     a second execution is attempted.)  Memory observability AsyncTask guarantees that all callback calls are synchronized in such a way that the following operations are safe without explicit synchronizations.      Set member fields in the constructor or onPreExecute(), and refer to them     in doInBackground(Params...).     Set member fields in doInBackground(Params...), and refer to them in     onProgressUpdate(Progress...) and onPostExecute(Result).  Order of execution When first introduced, AsyncTasks were executed serially on a single background thread. Starting with Build.VERSION_CODES.DONUT, this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting with Build.VERSION_CODES.HONEYCOMB, tasks are executed on a single thread to avoid common application errors caused by parallel execution. If you truly want parallel execution, you can invoke executeOnExecutor(java.util.concurrent.Executor, Object[]) with THREAD_POOL_EXECUTOR.",onPreExecute(),Runs on the UI thread before doInBackground(Params...).,protected void
io.fabric.sdk.android.services.concurrency.AsyncTask,"AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers. AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent pacakge such as Executor, ThreadPoolExecutor and FutureTask. An asynchronous task is defined by a computation that runs on a background thread and whose result is published on the UI thread. An asynchronous task is defined by 3 generic types, called Params, Progress and Result, and 4 steps, called onPreExecute, doInBackground, onProgressUpdate and onPostExecute.  Developer Guides For more information about using tasks and threads, read the Processes and Threads developer guide.  Usage AsyncTask must be subclassed to be used. The subclass will override at least one method (doInBackground(Params...)), and most often will override a second one (onPostExecute(Result).) Here is an example of subclassing:  private class DownloadFilesTask extends AsyncTask<URL, Integer, Long> {     protected Long doInBackground(URL... urls) {         int count = urls.length;         long totalSize = 0;         for (int i = 0; i < count; i++) {             totalSize += Downloader.downloadFile(urls[i]);             publishProgress((int) ((i / (float) count) * 100));             // Escape early if cancel() is called             if (isCancelled()) break;         }         return totalSize;     }     protected void onProgressUpdate(Integer... progress) {         setProgressPercent(progress[0]);     }     protected void onPostExecute(Long result) {         showDialog(""Downloaded "" + result + "" bytes"");     } }  Once created, a task is executed very simply:  new DownloadFilesTask().execute(url1, url2, url3);  AsyncTask's generic types The three types used by an asynchronous task are the following:      Params, the type of the parameters sent to the task upon     execution.     Progress, the type of the progress units published during     the background computation.     Result, the type of the result of the background     computation.  Not all types are always used by an asynchronous task. To mark a type as unused, simply use the type Void:  private class MyTask extends AsyncTask<Void, Void, Void> { ... }  The 4 steps When an asynchronous task is executed, the task goes through 4 steps:      onPreExecute(), invoked on the UI thread before the task     is executed. This step is normally used to setup the task, for instance by     showing a progress bar in the user interface.     doInBackground(Params...), invoked on the background thread     immediately after onPreExecute() finishes executing. This step is used     to perform background computation that can take a long time. The parameters     of the asynchronous task are passed to this step. The result of the computation must     be returned by this step and will be passed back to the last step. This step     can also use publishProgress(Progress...) to publish one or more units     of progress. These values are published on the UI thread, in the     onProgressUpdate(Progress...) step.     onProgressUpdate(Progress...), invoked on the UI thread after a     call to publishProgress(Progress...). The timing of the execution is     undefined. This method is used to display any form of progress in the user     interface while the background computation is still executing. For instance,     it can be used to animate a progress bar or show logs in a text field.     onPostExecute(Result), invoked on the UI thread after the background     computation finishes. The result of the background computation is passed to     this step as a parameter.  Cancelling a task A task can be cancelled at any time by invoking cancel(boolean). Invoking this method will cause subsequent calls to isCancelled() to return true. After invoking this method, onCancelled(Object), instead of onPostExecute(Object) will be invoked after doInBackground(Object[]) returns. To ensure that a task is cancelled as quickly as possible, you should always check the return value of isCancelled() periodically from doInBackground(Object[]), if possible (inside a loop for instance.) Threading rules There are a few threading rules that must be followed for this class to work properly:      The AsyncTask class must be loaded on the UI thread. This is done     automatically as of Build.VERSION_CODES.JELLY_BEAN.     The task instance must be created on the UI thread.     execute(Params...) must be invoked on the UI thread.     Do not call onPreExecute(), onPostExecute(Result),     doInBackground(Params...), onProgressUpdate(Progress...) manually.     The task can be executed only once (an exception will be thrown if     a second execution is attempted.)  Memory observability AsyncTask guarantees that all callback calls are synchronized in such a way that the following operations are safe without explicit synchronizations.      Set member fields in the constructor or onPreExecute(), and refer to them     in doInBackground(Params...).     Set member fields in doInBackground(Params...), and refer to them in     onProgressUpdate(Progress...) and onPostExecute(Result).  Order of execution When first introduced, AsyncTasks were executed serially on a single background thread. Starting with Build.VERSION_CODES.DONUT, this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting with Build.VERSION_CODES.HONEYCOMB, tasks are executed on a single thread to avoid common application errors caused by parallel execution. If you truly want parallel execution, you can invoke executeOnExecutor(java.util.concurrent.Executor, Object[]) with THREAD_POOL_EXECUTOR.",onProgressUpdate(Progress... values),Runs on the UI thread after publishProgress(Progress...) is invoked.,protected void
io.fabric.sdk.android.services.concurrency.AsyncTask,"AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers. AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent pacakge such as Executor, ThreadPoolExecutor and FutureTask. An asynchronous task is defined by a computation that runs on a background thread and whose result is published on the UI thread. An asynchronous task is defined by 3 generic types, called Params, Progress and Result, and 4 steps, called onPreExecute, doInBackground, onProgressUpdate and onPostExecute.  Developer Guides For more information about using tasks and threads, read the Processes and Threads developer guide.  Usage AsyncTask must be subclassed to be used. The subclass will override at least one method (doInBackground(Params...)), and most often will override a second one (onPostExecute(Result).) Here is an example of subclassing:  private class DownloadFilesTask extends AsyncTask<URL, Integer, Long> {     protected Long doInBackground(URL... urls) {         int count = urls.length;         long totalSize = 0;         for (int i = 0; i < count; i++) {             totalSize += Downloader.downloadFile(urls[i]);             publishProgress((int) ((i / (float) count) * 100));             // Escape early if cancel() is called             if (isCancelled()) break;         }         return totalSize;     }     protected void onProgressUpdate(Integer... progress) {         setProgressPercent(progress[0]);     }     protected void onPostExecute(Long result) {         showDialog(""Downloaded "" + result + "" bytes"");     } }  Once created, a task is executed very simply:  new DownloadFilesTask().execute(url1, url2, url3);  AsyncTask's generic types The three types used by an asynchronous task are the following:      Params, the type of the parameters sent to the task upon     execution.     Progress, the type of the progress units published during     the background computation.     Result, the type of the result of the background     computation.  Not all types are always used by an asynchronous task. To mark a type as unused, simply use the type Void:  private class MyTask extends AsyncTask<Void, Void, Void> { ... }  The 4 steps When an asynchronous task is executed, the task goes through 4 steps:      onPreExecute(), invoked on the UI thread before the task     is executed. This step is normally used to setup the task, for instance by     showing a progress bar in the user interface.     doInBackground(Params...), invoked on the background thread     immediately after onPreExecute() finishes executing. This step is used     to perform background computation that can take a long time. The parameters     of the asynchronous task are passed to this step. The result of the computation must     be returned by this step and will be passed back to the last step. This step     can also use publishProgress(Progress...) to publish one or more units     of progress. These values are published on the UI thread, in the     onProgressUpdate(Progress...) step.     onProgressUpdate(Progress...), invoked on the UI thread after a     call to publishProgress(Progress...). The timing of the execution is     undefined. This method is used to display any form of progress in the user     interface while the background computation is still executing. For instance,     it can be used to animate a progress bar or show logs in a text field.     onPostExecute(Result), invoked on the UI thread after the background     computation finishes. The result of the background computation is passed to     this step as a parameter.  Cancelling a task A task can be cancelled at any time by invoking cancel(boolean). Invoking this method will cause subsequent calls to isCancelled() to return true. After invoking this method, onCancelled(Object), instead of onPostExecute(Object) will be invoked after doInBackground(Object[]) returns. To ensure that a task is cancelled as quickly as possible, you should always check the return value of isCancelled() periodically from doInBackground(Object[]), if possible (inside a loop for instance.) Threading rules There are a few threading rules that must be followed for this class to work properly:      The AsyncTask class must be loaded on the UI thread. This is done     automatically as of Build.VERSION_CODES.JELLY_BEAN.     The task instance must be created on the UI thread.     execute(Params...) must be invoked on the UI thread.     Do not call onPreExecute(), onPostExecute(Result),     doInBackground(Params...), onProgressUpdate(Progress...) manually.     The task can be executed only once (an exception will be thrown if     a second execution is attempted.)  Memory observability AsyncTask guarantees that all callback calls are synchronized in such a way that the following operations are safe without explicit synchronizations.      Set member fields in the constructor or onPreExecute(), and refer to them     in doInBackground(Params...).     Set member fields in doInBackground(Params...), and refer to them in     onProgressUpdate(Progress...) and onPostExecute(Result).  Order of execution When first introduced, AsyncTasks were executed serially on a single background thread. Starting with Build.VERSION_CODES.DONUT, this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting with Build.VERSION_CODES.HONEYCOMB, tasks are executed on a single thread to avoid common application errors caused by parallel execution. If you truly want parallel execution, you can invoke executeOnExecutor(java.util.concurrent.Executor, Object[]) with THREAD_POOL_EXECUTOR.",publishProgress(Progress... values),This method can be invoked from doInBackground(Params...) to publish updates on the UI thread while the background computation is still running.,protected void
io.fabric.sdk.android.services.concurrency.AsyncTask,"AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers. AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent pacakge such as Executor, ThreadPoolExecutor and FutureTask. An asynchronous task is defined by a computation that runs on a background thread and whose result is published on the UI thread. An asynchronous task is defined by 3 generic types, called Params, Progress and Result, and 4 steps, called onPreExecute, doInBackground, onProgressUpdate and onPostExecute.  Developer Guides For more information about using tasks and threads, read the Processes and Threads developer guide.  Usage AsyncTask must be subclassed to be used. The subclass will override at least one method (doInBackground(Params...)), and most often will override a second one (onPostExecute(Result).) Here is an example of subclassing:  private class DownloadFilesTask extends AsyncTask<URL, Integer, Long> {     protected Long doInBackground(URL... urls) {         int count = urls.length;         long totalSize = 0;         for (int i = 0; i < count; i++) {             totalSize += Downloader.downloadFile(urls[i]);             publishProgress((int) ((i / (float) count) * 100));             // Escape early if cancel() is called             if (isCancelled()) break;         }         return totalSize;     }     protected void onProgressUpdate(Integer... progress) {         setProgressPercent(progress[0]);     }     protected void onPostExecute(Long result) {         showDialog(""Downloaded "" + result + "" bytes"");     } }  Once created, a task is executed very simply:  new DownloadFilesTask().execute(url1, url2, url3);  AsyncTask's generic types The three types used by an asynchronous task are the following:      Params, the type of the parameters sent to the task upon     execution.     Progress, the type of the progress units published during     the background computation.     Result, the type of the result of the background     computation.  Not all types are always used by an asynchronous task. To mark a type as unused, simply use the type Void:  private class MyTask extends AsyncTask<Void, Void, Void> { ... }  The 4 steps When an asynchronous task is executed, the task goes through 4 steps:      onPreExecute(), invoked on the UI thread before the task     is executed. This step is normally used to setup the task, for instance by     showing a progress bar in the user interface.     doInBackground(Params...), invoked on the background thread     immediately after onPreExecute() finishes executing. This step is used     to perform background computation that can take a long time. The parameters     of the asynchronous task are passed to this step. The result of the computation must     be returned by this step and will be passed back to the last step. This step     can also use publishProgress(Progress...) to publish one or more units     of progress. These values are published on the UI thread, in the     onProgressUpdate(Progress...) step.     onProgressUpdate(Progress...), invoked on the UI thread after a     call to publishProgress(Progress...). The timing of the execution is     undefined. This method is used to display any form of progress in the user     interface while the background computation is still executing. For instance,     it can be used to animate a progress bar or show logs in a text field.     onPostExecute(Result), invoked on the UI thread after the background     computation finishes. The result of the background computation is passed to     this step as a parameter.  Cancelling a task A task can be cancelled at any time by invoking cancel(boolean). Invoking this method will cause subsequent calls to isCancelled() to return true. After invoking this method, onCancelled(Object), instead of onPostExecute(Object) will be invoked after doInBackground(Object[]) returns. To ensure that a task is cancelled as quickly as possible, you should always check the return value of isCancelled() periodically from doInBackground(Object[]), if possible (inside a loop for instance.) Threading rules There are a few threading rules that must be followed for this class to work properly:      The AsyncTask class must be loaded on the UI thread. This is done     automatically as of Build.VERSION_CODES.JELLY_BEAN.     The task instance must be created on the UI thread.     execute(Params...) must be invoked on the UI thread.     Do not call onPreExecute(), onPostExecute(Result),     doInBackground(Params...), onProgressUpdate(Progress...) manually.     The task can be executed only once (an exception will be thrown if     a second execution is attempted.)  Memory observability AsyncTask guarantees that all callback calls are synchronized in such a way that the following operations are safe without explicit synchronizations.      Set member fields in the constructor or onPreExecute(), and refer to them     in doInBackground(Params...).     Set member fields in doInBackground(Params...), and refer to them in     onProgressUpdate(Progress...) and onPostExecute(Result).  Order of execution When first introduced, AsyncTasks were executed serially on a single background thread. Starting with Build.VERSION_CODES.DONUT, this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting with Build.VERSION_CODES.HONEYCOMB, tasks are executed on a single thread to avoid common application errors caused by parallel execution. If you truly want parallel execution, you can invoke executeOnExecutor(java.util.concurrent.Executor, Object[]) with THREAD_POOL_EXECUTOR.",setDefaultExecutor(Executor exec),N/A,static void
io.fabric.sdk.android.services.concurrency.AsyncTask.Status,Indicates the current status of the task. Each status will be set only once during the lifetime of a task.,valueOf(String name),Returns the enum constant of this type with the specified name.,static AsyncTask.Status
io.fabric.sdk.android.services.concurrency.AsyncTask.Status,Indicates the current status of the task. Each status will be set only once during the lifetime of a task.,values(),"Returns an array containing the constants of this enum type, inthe order they are declared.",static AsyncTask.Status[]
io.fabric.sdk.android.DefaultLogger,Default logger that logs to android.util.Log.,"d(String tag, String text)",N/A,void
io.fabric.sdk.android.DefaultLogger,Default logger that logs to android.util.Log.,"d(String tag, String text, Throwable throwable)",N/A,void
io.fabric.sdk.android.DefaultLogger,Default logger that logs to android.util.Log.,"e(String tag, String text)",N/A,void
io.fabric.sdk.android.DefaultLogger,Default logger that logs to android.util.Log.,"e(String tag, String text, Throwable throwable)",N/A,void
io.fabric.sdk.android.DefaultLogger,Default logger that logs to android.util.Log.,getLogLevel(),N/A,int
io.fabric.sdk.android.DefaultLogger,Default logger that logs to android.util.Log.,"i(String tag, String text)",N/A,void
io.fabric.sdk.android.DefaultLogger,Default logger that logs to android.util.Log.,"i(String tag, String text, Throwable throwable)",N/A,void
io.fabric.sdk.android.DefaultLogger,Default logger that logs to android.util.Log.,"isLoggable(String tag,          int level)",N/A,boolean
io.fabric.sdk.android.DefaultLogger,Default logger that logs to android.util.Log.,"log(int priority,   String tag,   String msg)",N/A,void
io.fabric.sdk.android.DefaultLogger,Default logger that logs to android.util.Log.,"log(int priority,   String tag,   String msg,   boolean forceLog)",N/A,void
io.fabric.sdk.android.DefaultLogger,Default logger that logs to android.util.Log.,setLogLevel(int logLevel),N/A,void
io.fabric.sdk.android.DefaultLogger,Default logger that logs to android.util.Log.,"v(String tag, String text)",N/A,void
io.fabric.sdk.android.DefaultLogger,Default logger that logs to android.util.Log.,"v(String tag, String text, Throwable throwable)",N/A,void
io.fabric.sdk.android.DefaultLogger,Default logger that logs to android.util.Log.,"w(String tag, String text)",N/A,void
io.fabric.sdk.android.DefaultLogger,Default logger that logs to android.util.Log.,"w(String tag, String text, Throwable throwable)",N/A,void
io.fabric.sdk.android.services.concurrency.DelegateProvider,Allows the implementer to provide a delegate to proxy concurrency methods,getDelegate(),Returns a delegate to be used when the parent class of the implementor can extend from a PriorityTask,<T extends Dependency<Task> & PriorityProvider & Task>T
io.fabric.sdk.android.services.concurrency.Dependency,Represents dependency to be used with PriorityThreadPoolExecutor,addDependency(T dependable),Assign dependency on specified T.,void
io.fabric.sdk.android.services.concurrency.Dependency,Represents dependency to be used with PriorityThreadPoolExecutor,areDependenciesMet(),Returns true when the dependencies have been met,boolean
io.fabric.sdk.android.services.concurrency.Dependency,Represents dependency to be used with PriorityThreadPoolExecutor,getDependencies(),fulfilled before the Dependency instance.,Collection<T>
io.fabric.sdk.android.services.concurrency.DependencyPriorityBlockingQueue,"The DependencyPriorityBlockingQueue provides all functionality of a PriorityBlockingQueue while simultaneously supporting task dependencies using the Dependency interface. An independent worker is guaranteed to complete before the dependent worker that specifies it. Priorities are specified by the worker extending the Priority class. When Priorities and Dependencies conflict, the expectation in a dependency chain is that the entire chain will run at the priority specified by the independent worker. No effort is made to guarantee all dependencies are satisfied. Responsibility falls on outside components to validate the dependency graph for complete execution.",clear(),N/A,void
io.fabric.sdk.android.services.concurrency.DependencyPriorityBlockingQueue,"The DependencyPriorityBlockingQueue provides all functionality of a PriorityBlockingQueue while simultaneously supporting task dependencies using the Dependency interface. An independent worker is guaranteed to complete before the dependent worker that specifies it. Priorities are specified by the worker extending the Priority class. When Priorities and Dependencies conflict, the expectation in a dependency chain is that the entire chain will run at the priority specified by the independent worker. No effort is made to guarantee all dependencies are satisfied. Responsibility falls on outside components to validate the dependency graph for complete execution.",contains(Object o),N/A,boolean
io.fabric.sdk.android.services.concurrency.DependencyPriorityBlockingQueue,"The DependencyPriorityBlockingQueue provides all functionality of a PriorityBlockingQueue while simultaneously supporting task dependencies using the Dependency interface. An independent worker is guaranteed to complete before the dependent worker that specifies it. Priorities are specified by the worker extending the Priority class. When Priorities and Dependencies conflict, the expectation in a dependency chain is that the entire chain will run at the priority specified by the independent worker. No effort is made to guarantee all dependencies are satisfied. Responsibility falls on outside components to validate the dependency graph for complete execution.",drainTo(Collection<? super E> c),N/A,int
io.fabric.sdk.android.services.concurrency.DependencyPriorityBlockingQueue,"The DependencyPriorityBlockingQueue provides all functionality of a PriorityBlockingQueue while simultaneously supporting task dependencies using the Dependency interface. An independent worker is guaranteed to complete before the dependent worker that specifies it. Priorities are specified by the worker extending the Priority class. When Priorities and Dependencies conflict, the expectation in a dependency chain is that the entire chain will run at the priority specified by the independent worker. No effort is made to guarantee all dependencies are satisfied. Responsibility falls on outside components to validate the dependency graph for complete execution.","drainTo(Collection<? super E> c,       int maxElements)",N/A,int
io.fabric.sdk.android.services.concurrency.DependencyPriorityBlockingQueue,"The DependencyPriorityBlockingQueue provides all functionality of a PriorityBlockingQueue while simultaneously supporting task dependencies using the Dependency interface. An independent worker is guaranteed to complete before the dependent worker that specifies it. Priorities are specified by the worker extending the Priority class. When Priorities and Dependencies conflict, the expectation in a dependency chain is that the entire chain will run at the priority specified by the independent worker. No effort is made to guarantee all dependencies are satisfied. Responsibility falls on outside components to validate the dependency graph for complete execution.",peek(),N/A,E
io.fabric.sdk.android.services.concurrency.DependencyPriorityBlockingQueue,"The DependencyPriorityBlockingQueue provides all functionality of a PriorityBlockingQueue while simultaneously supporting task dependencies using the Dependency interface. An independent worker is guaranteed to complete before the dependent worker that specifies it. Priorities are specified by the worker extending the Priority class. When Priorities and Dependencies conflict, the expectation in a dependency chain is that the entire chain will run at the priority specified by the independent worker. No effort is made to guarantee all dependencies are satisfied. Responsibility falls on outside components to validate the dependency graph for complete execution.",poll(),N/A,E
io.fabric.sdk.android.services.concurrency.DependencyPriorityBlockingQueue,"The DependencyPriorityBlockingQueue provides all functionality of a PriorityBlockingQueue while simultaneously supporting task dependencies using the Dependency interface. An independent worker is guaranteed to complete before the dependent worker that specifies it. Priorities are specified by the worker extending the Priority class. When Priorities and Dependencies conflict, the expectation in a dependency chain is that the entire chain will run at the priority specified by the independent worker. No effort is made to guarantee all dependencies are satisfied. Responsibility falls on outside components to validate the dependency graph for complete execution.","poll(long timeout,    TimeUnit unit)",N/A,E
io.fabric.sdk.android.services.concurrency.DependencyPriorityBlockingQueue,"The DependencyPriorityBlockingQueue provides all functionality of a PriorityBlockingQueue while simultaneously supporting task dependencies using the Dependency interface. An independent worker is guaranteed to complete before the dependent worker that specifies it. Priorities are specified by the worker extending the Priority class. When Priorities and Dependencies conflict, the expectation in a dependency chain is that the entire chain will run at the priority specified by the independent worker. No effort is made to guarantee all dependencies are satisfied. Responsibility falls on outside components to validate the dependency graph for complete execution.",recycleBlockedQueue(),Removes all items from blocked Queue and inserts into primary queue to retry.,void
io.fabric.sdk.android.services.concurrency.DependencyPriorityBlockingQueue,"The DependencyPriorityBlockingQueue provides all functionality of a PriorityBlockingQueue while simultaneously supporting task dependencies using the Dependency interface. An independent worker is guaranteed to complete before the dependent worker that specifies it. Priorities are specified by the worker extending the Priority class. When Priorities and Dependencies conflict, the expectation in a dependency chain is that the entire chain will run at the priority specified by the independent worker. No effort is made to guarantee all dependencies are satisfied. Responsibility falls on outside components to validate the dependency graph for complete execution.",remove(Object o),N/A,boolean
io.fabric.sdk.android.services.concurrency.DependencyPriorityBlockingQueue,"The DependencyPriorityBlockingQueue provides all functionality of a PriorityBlockingQueue while simultaneously supporting task dependencies using the Dependency interface. An independent worker is guaranteed to complete before the dependent worker that specifies it. Priorities are specified by the worker extending the Priority class. When Priorities and Dependencies conflict, the expectation in a dependency chain is that the entire chain will run at the priority specified by the independent worker. No effort is made to guarantee all dependencies are satisfied. Responsibility falls on outside components to validate the dependency graph for complete execution.",removeAll(Collection<?> collection),N/A,boolean
io.fabric.sdk.android.services.concurrency.DependencyPriorityBlockingQueue,"The DependencyPriorityBlockingQueue provides all functionality of a PriorityBlockingQueue while simultaneously supporting task dependencies using the Dependency interface. An independent worker is guaranteed to complete before the dependent worker that specifies it. Priorities are specified by the worker extending the Priority class. When Priorities and Dependencies conflict, the expectation in a dependency chain is that the entire chain will run at the priority specified by the independent worker. No effort is made to guarantee all dependencies are satisfied. Responsibility falls on outside components to validate the dependency graph for complete execution.",size(),N/A,int
io.fabric.sdk.android.services.concurrency.DependencyPriorityBlockingQueue,"The DependencyPriorityBlockingQueue provides all functionality of a PriorityBlockingQueue while simultaneously supporting task dependencies using the Dependency interface. An independent worker is guaranteed to complete before the dependent worker that specifies it. Priorities are specified by the worker extending the Priority class. When Priorities and Dependencies conflict, the expectation in a dependency chain is that the entire chain will run at the priority specified by the independent worker. No effort is made to guarantee all dependencies are satisfied. Responsibility falls on outside components to validate the dependency graph for complete execution.",take(),N/A,E
io.fabric.sdk.android.services.concurrency.DependencyPriorityBlockingQueue,"The DependencyPriorityBlockingQueue provides all functionality of a PriorityBlockingQueue while simultaneously supporting task dependencies using the Dependency interface. An independent worker is guaranteed to complete before the dependent worker that specifies it. Priorities are specified by the worker extending the Priority class. When Priorities and Dependencies conflict, the expectation in a dependency chain is that the entire chain will run at the priority specified by the independent worker. No effort is made to guarantee all dependencies are satisfied. Responsibility falls on outside components to validate the dependency graph for complete execution.",toArray(),N/A,Object[]
io.fabric.sdk.android.services.concurrency.DependencyPriorityBlockingQueue,"The DependencyPriorityBlockingQueue provides all functionality of a PriorityBlockingQueue while simultaneously supporting task dependencies using the Dependency interface. An independent worker is guaranteed to complete before the dependent worker that specifies it. Priorities are specified by the worker extending the Priority class. When Priorities and Dependencies conflict, the expectation in a dependency chain is that the entire chain will run at the priority specified by the independent worker. No effort is made to guarantee all dependencies are satisfied. Responsibility falls on outside components to validate the dependency graph for complete execution.",toArray(T[] a),N/A,<T> T[]
io.fabric.sdk.android.services.concurrency.DependsOn,Allows a Kit to specify a Dependency for initialization.,N/A,N/A,N/A
io.fabric.sdk.android.Fabric,Fabric initializes and stores the provided Kit's.,getActivityLifecycleManager(),N/A,ActivityLifecycleManager
io.fabric.sdk.android.Fabric,Fabric initializes and stores the provided Kit's.,getAppIdentifier(),The value for the Application Identifier (defaults to package name).,String
io.fabric.sdk.android.Fabric,Fabric initializes and stores the provided Kit's.,getAppInstallIdentifier(),"The overridden value for the Application Install Identifier, or a generated value.",String
io.fabric.sdk.android.Fabric,Fabric initializes and stores the provided Kit's.,getCurrentActivity(),N/A,Activity
io.fabric.sdk.android.Fabric,Fabric initializes and stores the provided Kit's.,getExecutorService(),N/A,ExecutorService
io.fabric.sdk.android.Fabric,Fabric initializes and stores the provided Kit's.,getIdentifier(),N/A,String
io.fabric.sdk.android.Fabric,Fabric initializes and stores the provided Kit's.,getKit(Class<T> cls),N/A,static <T extends Kit>T
io.fabric.sdk.android.Fabric,Fabric initializes and stores the provided Kit's.,getKits(),Returns the Kits registered with SDK.,Collection<Kit>
io.fabric.sdk.android.Fabric,Fabric initializes and stores the provided Kit's.,getLogger(),Returns the global Logger.,static Logger
io.fabric.sdk.android.Fabric,Fabric initializes and stores the provided Kit's.,getMainHandler(),N/A,Handler
io.fabric.sdk.android.Fabric,Fabric initializes and stores the provided Kit's.,getVersion(),N/A,String
io.fabric.sdk.android.Fabric,Fabric initializes and stores the provided Kit's.,isDebuggable(),Returns the global value for debug mode.,static boolean
io.fabric.sdk.android.Fabric,Fabric initializes and stores the provided Kit's.,isInitialized(),Returns true when all kits have finished asynchronous initialization.,static boolean
io.fabric.sdk.android.Fabric,Fabric initializes and stores the provided Kit's.,setCurrentActivity(Activity activity),Used for Fabric to Display UI components.,Fabric
io.fabric.sdk.android.Fabric,Fabric initializes and stores the provided Kit's.,"with(Context context,    Kit... kits)",Entry point to initialize Fabric and contained Kits.,static Fabric
io.fabric.sdk.android.Fabric,Fabric initializes and stores the provided Kit's.,with(Fabric fabric),Entry point to initialize Fabric and contained Kits.,static Fabric
io.fabric.sdk.android.Fabric.Builder,Fluent API for creating Fabric instances.,appIdentifier(String appIdentifier),Sets the Application Identifier to build with.,Fabric.Builder
io.fabric.sdk.android.Fabric.Builder,Fluent API for creating Fabric instances.,appInstallIdentifier(String appInstallIdentifier),Sets the Application Install Identifier to build with,Fabric.Builder
io.fabric.sdk.android.Fabric.Builder,Fluent API for creating Fabric instances.,build(),Build the fabric instance,Fabric
io.fabric.sdk.android.Fabric.Builder,Fluent API for creating Fabric instances.,debuggable(boolean enabled),Enable Logging,Fabric.Builder
io.fabric.sdk.android.Fabric.Builder,Fluent API for creating Fabric instances.,executorService(ExecutorService executorService),Deprecated. Use threadPoolExecutor(io.fabric.sdk.android.services.concurrency.PriorityThreadPoolExecutor),Fabric.Builder
io.fabric.sdk.android.Fabric.Builder,Fluent API for creating Fabric instances.,handler(Handler handler),Deprecated. this always uses the main handler,Fabric.Builder
io.fabric.sdk.android.Fabric.Builder,Fluent API for creating Fabric instances.,initializationCallback(InitializationCallback<Fabric> initializationCallback),Specify the InitializationCallbackto build with,Fabric.Builder
io.fabric.sdk.android.Fabric.Builder,Fluent API for creating Fabric instances.,kits(Kit... kits),Sets the Kit array to build with.,Fabric.Builder
io.fabric.sdk.android.Fabric.Builder,Fluent API for creating Fabric instances.,logger(Logger logger),Sets the Logger to build with.,Fabric.Builder
io.fabric.sdk.android.Fabric.Builder,Fluent API for creating Fabric instances.,threadPoolExecutor(PriorityThreadPoolExecutor threadPoolExecutor),Sets the PriorityThreadPoolExecutor to build with.,Fabric.Builder
io.fabric.sdk.android.InitializationCallback,Callback to use when monitoring Fabric initialization. Use by calling Fabric.Builder.initializationCallback(InitializationCallback),failure(Exception exception),Failed initialization with exception,void
io.fabric.sdk.android.InitializationCallback,Callback to use when monitoring Fabric initialization. Use by calling Fabric.Builder.initializationCallback(InitializationCallback),success(T t),Successful initialization.,void
io.fabric.sdk.android.InitializationCallback.Empty,Failed initialization with exception,failure(Exception exception),Failed initialization with exception,void
io.fabric.sdk.android.InitializationCallback.Empty,Failed initialization with exception,success(Object object),Successful initialization.,void
io.fabric.sdk.android.InitializationException,Represents a Fabric initialization error.,N/A,N/A,N/A
io.fabric.sdk.android.Kit,"The base class to extend from for classes needing initialization with Fabric.with(android.content.Context, Kit[])",compareTo(Kit another),Compares Kit's using Dependency,int
io.fabric.sdk.android.Kit,"The base class to extend from for classes needing initialization with Fabric.with(android.content.Context, Kit[])",doInBackground(),For heavy work to be done in initialization process on a background thread.,protected abstract Result
io.fabric.sdk.android.Kit,"The base class to extend from for classes needing initialization with Fabric.with(android.content.Context, Kit[])",getContext(),N/A,Context
io.fabric.sdk.android.Kit,"The base class to extend from for classes needing initialization with Fabric.with(android.content.Context, Kit[])",getDependencies(),N/A,protected Collection<Task>
io.fabric.sdk.android.Kit,"The base class to extend from for classes needing initialization with Fabric.with(android.content.Context, Kit[])",getFabric(),N/A,Fabric
io.fabric.sdk.android.Kit,"The base class to extend from for classes needing initialization with Fabric.with(android.content.Context, Kit[])",getIdentifier(),Must be implemented by Kit to allow plugin on-boarding,abstract String
io.fabric.sdk.android.Kit,"The base class to extend from for classes needing initialization with Fabric.with(android.content.Context, Kit[])",getIdManager(),N/A,protected IdManager
io.fabric.sdk.android.Kit,"The base class to extend from for classes needing initialization with Fabric.with(android.content.Context, Kit[])",getPath(),N/A,String
io.fabric.sdk.android.Kit,"The base class to extend from for classes needing initialization with Fabric.with(android.content.Context, Kit[])",getVersion(),N/A,abstract String
io.fabric.sdk.android.Kit,"The base class to extend from for classes needing initialization with Fabric.with(android.content.Context, Kit[])",onCancelled(Result result),Called after doInBackground() is cancelled on the UI thread,protected void
io.fabric.sdk.android.Kit,"The base class to extend from for classes needing initialization with Fabric.with(android.content.Context, Kit[])",onPostExecute(Result result),Called after doInBackground() completes on the UI thread,protected void
io.fabric.sdk.android.Kit,"The base class to extend from for classes needing initialization with Fabric.with(android.content.Context, Kit[])",onPreExecute(),Called before intialization on the UI thread,protected boolean
io.fabric.sdk.android.KitGroup,Wrapper for a set of logically grouped Kit's.,getKits(),N/A,Collection<? extends Kit>
io.fabric.sdk.android.KitInfo,N/A,getBuildType(),N/A,String
io.fabric.sdk.android.KitInfo,N/A,getIdentifier(),N/A,String
io.fabric.sdk.android.KitInfo,N/A,getVersion(),N/A,String
io.fabric.sdk.android.Logger,Interface to support custom logger.,"d(String tag, String text)",N/A,void
io.fabric.sdk.android.Logger,Interface to support custom logger.,"d(String tag, String text, Throwable throwable)",N/A,void
io.fabric.sdk.android.Logger,Interface to support custom logger.,"e(String tag, String text)",N/A,void
io.fabric.sdk.android.Logger,Interface to support custom logger.,"e(String tag, String text, Throwable throwable)",N/A,void
io.fabric.sdk.android.Logger,Interface to support custom logger.,getLogLevel(),N/A,int
io.fabric.sdk.android.Logger,Interface to support custom logger.,"i(String tag, String text)",N/A,void
io.fabric.sdk.android.Logger,Interface to support custom logger.,"i(String tag, String text, Throwable throwable)",N/A,void
io.fabric.sdk.android.Logger,Interface to support custom logger.,"isLoggable(String tag,          int level)",N/A,boolean
io.fabric.sdk.android.Logger,Interface to support custom logger.,"log(int priority,   String tag,   String msg)",N/A,void
io.fabric.sdk.android.Logger,Interface to support custom logger.,"log(int priority,   String tag,   String msg,   boolean forceLog)",N/A,void
io.fabric.sdk.android.Logger,Interface to support custom logger.,setLogLevel(int logLevel),N/A,void
io.fabric.sdk.android.Logger,Interface to support custom logger.,"v(String tag, String text)",N/A,void
io.fabric.sdk.android.Logger,Interface to support custom logger.,"v(String tag, String text, Throwable throwable)",N/A,void
io.fabric.sdk.android.Logger,Interface to support custom logger.,"w(String tag, String text)",N/A,void
io.fabric.sdk.android.Logger,Interface to support custom logger.,"w(String tag, String text, Throwable throwable)",N/A,void
io.fabric.sdk.android.services.concurrency.Priority,enum to define ordering for PriorityBlockingQueue in PriorityThreadPoolExecutor,valueOf(String name),Returns the enum constant of this type with the specified name.,static Priority
io.fabric.sdk.android.services.concurrency.Priority,enum to define ordering for PriorityBlockingQueue in PriorityThreadPoolExecutor,values(),"Returns an array containing the constants of this enum type, inthe order they are declared.",static Priority[]
io.fabric.sdk.android.services.concurrency.PriorityAsyncTask,AsyncTask that provides priority for PriorityThreadPoolExecutor,addDependency(Task task),Adds a Dependency,void
io.fabric.sdk.android.services.concurrency.PriorityAsyncTask,AsyncTask that provides priority for PriorityThreadPoolExecutor,areDependenciesMet(),Returns true when the dependencies have been met,boolean
io.fabric.sdk.android.services.concurrency.PriorityAsyncTask,AsyncTask that provides priority for PriorityThreadPoolExecutor,compareTo(Object another),N/A,int
io.fabric.sdk.android.services.concurrency.PriorityAsyncTask,AsyncTask that provides priority for PriorityThreadPoolExecutor,"executeOnExecutor(ExecutorService exec,                 Params... params)",N/A,void
io.fabric.sdk.android.services.concurrency.PriorityAsyncTask,AsyncTask that provides priority for PriorityThreadPoolExecutor,getDelegate(),Returns a delegate to be used when the parent class of the implementor can extend from a PriorityTask,<T extends Dependency<Task> & PriorityProvider & Task>T
io.fabric.sdk.android.services.concurrency.PriorityAsyncTask,AsyncTask that provides priority for PriorityThreadPoolExecutor,getDependencies(),fulfilled before the Dependency instance.,Collection<Task>
io.fabric.sdk.android.services.concurrency.PriorityAsyncTask,AsyncTask that provides priority for PriorityThreadPoolExecutor,getError(),N/A,Throwable
io.fabric.sdk.android.services.concurrency.PriorityAsyncTask,AsyncTask that provides priority for PriorityThreadPoolExecutor,getPriority(),N/A,Priority
io.fabric.sdk.android.services.concurrency.PriorityAsyncTask,AsyncTask that provides priority for PriorityThreadPoolExecutor,isFinished(),N/A,boolean
io.fabric.sdk.android.services.concurrency.PriorityAsyncTask,AsyncTask that provides priority for PriorityThreadPoolExecutor,setError(Throwable throwable),N/A,void
io.fabric.sdk.android.services.concurrency.PriorityAsyncTask,AsyncTask that provides priority for PriorityThreadPoolExecutor,setFinished(boolean finished),Marks Task as finished,void
io.fabric.sdk.android.services.concurrency.PriorityCallable,Callable that provides priority for PriorityThreadPoolExecutor,N/A,N/A,N/A
io.fabric.sdk.android.services.concurrency.PriorityFutureTask,"FutureTask that provides priority for PriorityThreadPoolExecutor Tries to cast runnable/callable to type that implements Dependency, PriorityProvider, and Task. This classes uses PriorityTask as default if cast cannot happen.",addDependency(Task task),Assign dependency on specified T.,void
io.fabric.sdk.android.services.concurrency.PriorityFutureTask,"FutureTask that provides priority for PriorityThreadPoolExecutor Tries to cast runnable/callable to type that implements Dependency, PriorityProvider, and Task. This classes uses PriorityTask as default if cast cannot happen.",areDependenciesMet(),Returns true when the dependencies have been met,boolean
io.fabric.sdk.android.services.concurrency.PriorityFutureTask,"FutureTask that provides priority for PriorityThreadPoolExecutor Tries to cast runnable/callable to type that implements Dependency, PriorityProvider, and Task. This classes uses PriorityTask as default if cast cannot happen.",checkAndInitDelegate(Object object),N/A,protected <T extends Dependency<Task> & PriorityProvider & Task>T
io.fabric.sdk.android.services.concurrency.PriorityFutureTask,"FutureTask that provides priority for PriorityThreadPoolExecutor Tries to cast runnable/callable to type that implements Dependency, PriorityProvider, and Task. This classes uses PriorityTask as default if cast cannot happen.",compareTo(Object another),N/A,int
io.fabric.sdk.android.services.concurrency.PriorityFutureTask,"FutureTask that provides priority for PriorityThreadPoolExecutor Tries to cast runnable/callable to type that implements Dependency, PriorityProvider, and Task. This classes uses PriorityTask as default if cast cannot happen.",getDelegate(),Returns a delegate to be used when the parent class of the implementor can extend from a PriorityTask,<T extends Dependency<Task> & PriorityProvider & Task>T
io.fabric.sdk.android.services.concurrency.PriorityFutureTask,"FutureTask that provides priority for PriorityThreadPoolExecutor Tries to cast runnable/callable to type that implements Dependency, PriorityProvider, and Task. This classes uses PriorityTask as default if cast cannot happen.",getDependencies(),fulfilled before the Dependency instance.,Collection<Task>
io.fabric.sdk.android.services.concurrency.PriorityFutureTask,"FutureTask that provides priority for PriorityThreadPoolExecutor Tries to cast runnable/callable to type that implements Dependency, PriorityProvider, and Task. This classes uses PriorityTask as default if cast cannot happen.",getError(),N/A,Throwable
io.fabric.sdk.android.services.concurrency.PriorityFutureTask,"FutureTask that provides priority for PriorityThreadPoolExecutor Tries to cast runnable/callable to type that implements Dependency, PriorityProvider, and Task. This classes uses PriorityTask as default if cast cannot happen.",getPriority(),N/A,Priority
io.fabric.sdk.android.services.concurrency.PriorityFutureTask,"FutureTask that provides priority for PriorityThreadPoolExecutor Tries to cast runnable/callable to type that implements Dependency, PriorityProvider, and Task. This classes uses PriorityTask as default if cast cannot happen.",isFinished(),N/A,boolean
io.fabric.sdk.android.services.concurrency.PriorityFutureTask,"FutureTask that provides priority for PriorityThreadPoolExecutor Tries to cast runnable/callable to type that implements Dependency, PriorityProvider, and Task. This classes uses PriorityTask as default if cast cannot happen.",setError(Throwable throwable),N/A,void
io.fabric.sdk.android.services.concurrency.PriorityFutureTask,"FutureTask that provides priority for PriorityThreadPoolExecutor Tries to cast runnable/callable to type that implements Dependency, PriorityProvider, and Task. This classes uses PriorityTask as default if cast cannot happen.",setFinished(boolean finished),Marks Task as finished,void
io.fabric.sdk.android.services.concurrency.PriorityProvider,N/A,getPriority(),N/A,Priority
io.fabric.sdk.android.services.concurrency.PriorityRunnable,Runnable that provides priority for PriorityThreadPoolExecutor,N/A,N/A,N/A
io.fabric.sdk.android.services.concurrency.PriorityTask,"Base class for Priority based worker Can also be used as delegate for non extensible existing classes, such as AsyncTask",addDependency(Task task),Assign dependency on specified T.,void
io.fabric.sdk.android.services.concurrency.PriorityTask,"Base class for Priority based worker Can also be used as delegate for non extensible existing classes, such as AsyncTask",areDependenciesMet(),Returns true when the dependencies have been met,boolean
io.fabric.sdk.android.services.concurrency.PriorityTask,"Base class for Priority based worker Can also be used as delegate for non extensible existing classes, such as AsyncTask",compareTo(Object other),N/A,int
io.fabric.sdk.android.services.concurrency.PriorityTask,"Base class for Priority based worker Can also be used as delegate for non extensible existing classes, such as AsyncTask",getDependencies(),fulfilled before the Dependency instance.,Collection<Task>
io.fabric.sdk.android.services.concurrency.PriorityTask,"Base class for Priority based worker Can also be used as delegate for non extensible existing classes, such as AsyncTask",getError(),N/A,Throwable
io.fabric.sdk.android.services.concurrency.PriorityTask,"Base class for Priority based worker Can also be used as delegate for non extensible existing classes, such as AsyncTask",getPriority(),N/A,Priority
io.fabric.sdk.android.services.concurrency.PriorityTask,"Base class for Priority based worker Can also be used as delegate for non extensible existing classes, such as AsyncTask",isFinished(),N/A,boolean
io.fabric.sdk.android.services.concurrency.PriorityTask,"Base class for Priority based worker Can also be used as delegate for non extensible existing classes, such as AsyncTask",isProperDelegate(Object object),N/A,static boolean
io.fabric.sdk.android.services.concurrency.PriorityTask,"Base class for Priority based worker Can also be used as delegate for non extensible existing classes, such as AsyncTask",setError(Throwable throwable),N/A,void
io.fabric.sdk.android.services.concurrency.PriorityTask,"Base class for Priority based worker Can also be used as delegate for non extensible existing classes, such as AsyncTask",setFinished(boolean finished),Marks Task as finished,void
io.fabric.sdk.android.services.concurrency.PriorityThreadPoolExecutor,ThreadPoolExecutor that implements a DependencyPriorityBlockingQueue. This supports both Dependency and Priority functionality.,"afterExecute(Runnable runnable,            Throwable throwable)",N/A,protected void
io.fabric.sdk.android.services.concurrency.PriorityThreadPoolExecutor,ThreadPoolExecutor that implements a DependencyPriorityBlockingQueue. This supports both Dependency and Priority functionality.,create(),Creates default PriorityThreadPoolExecutor backed by a PriorityBlockingQueue,static PriorityThreadPoolExecutor
io.fabric.sdk.android.services.concurrency.PriorityThreadPoolExecutor,ThreadPoolExecutor that implements a DependencyPriorityBlockingQueue. This supports both Dependency and Priority functionality.,create(int threadCount),N/A,static PriorityThreadPoolExecutor
io.fabric.sdk.android.services.concurrency.PriorityThreadPoolExecutor,ThreadPoolExecutor that implements a DependencyPriorityBlockingQueue. This supports both Dependency and Priority functionality.,"create(int corePoolSize,      int maxPoolSize)",N/A,static <T extends Runnable & Dependency & Task & PriorityProvider>PriorityThreadPoolExecutor
io.fabric.sdk.android.services.concurrency.PriorityThreadPoolExecutor,ThreadPoolExecutor that implements a DependencyPriorityBlockingQueue. This supports both Dependency and Priority functionality.,execute(Runnable command),N/A,void
io.fabric.sdk.android.services.concurrency.PriorityThreadPoolExecutor,ThreadPoolExecutor that implements a DependencyPriorityBlockingQueue. This supports both Dependency and Priority functionality.,getQueue(),N/A,DependencyPriorityBlockingQueue
io.fabric.sdk.android.services.concurrency.PriorityThreadPoolExecutor,ThreadPoolExecutor that implements a DependencyPriorityBlockingQueue. This supports both Dependency and Priority functionality.,newTaskFor(Callable<T> callable),N/A,protected <T> RunnableFuture<T>
io.fabric.sdk.android.services.concurrency.PriorityThreadPoolExecutor,ThreadPoolExecutor that implements a DependencyPriorityBlockingQueue. This supports both Dependency and Priority functionality.,"newTaskFor(Runnable runnable,          T value)",N/A,protected <T> RunnableFuture<T>
io.fabric.sdk.android.services.concurrency.PriorityThreadPoolExecutor.PriorityThreadFactory,N/A,newThread(Runnable r),N/A,Thread
io.fabric.sdk.android.SilentLogger,Silent logger that does nothing.,"d(String tag, String text)",N/A,void
io.fabric.sdk.android.SilentLogger,Silent logger that does nothing.,"d(String tag, String text, Throwable throwable)",N/A,void
io.fabric.sdk.android.SilentLogger,Silent logger that does nothing.,"e(String tag, String text)",N/A,void
io.fabric.sdk.android.SilentLogger,Silent logger that does nothing.,"e(String tag, String text, Throwable throwable)",N/A,void
io.fabric.sdk.android.SilentLogger,Silent logger that does nothing.,getLogLevel(),N/A,int
io.fabric.sdk.android.SilentLogger,Silent logger that does nothing.,"i(String tag, String text)",N/A,void
io.fabric.sdk.android.SilentLogger,Silent logger that does nothing.,"i(String tag, String text, Throwable throwable)",N/A,void
io.fabric.sdk.android.SilentLogger,Silent logger that does nothing.,"isLoggable(String tag,          int level)",N/A,boolean
io.fabric.sdk.android.SilentLogger,Silent logger that does nothing.,"log(int priority,   String tag,   String msg)",N/A,void
io.fabric.sdk.android.SilentLogger,Silent logger that does nothing.,"log(int priority,   String tag,   String msg,   boolean forceLog)",N/A,void
io.fabric.sdk.android.SilentLogger,Silent logger that does nothing.,setLogLevel(int logLevel),N/A,void
io.fabric.sdk.android.SilentLogger,Silent logger that does nothing.,"v(String tag, String text)",N/A,void
io.fabric.sdk.android.SilentLogger,Silent logger that does nothing.,"v(String tag, String text, Throwable throwable)",N/A,void
io.fabric.sdk.android.SilentLogger,Silent logger that does nothing.,"w(String tag, String text)",N/A,void
io.fabric.sdk.android.SilentLogger,Silent logger that does nothing.,"w(String tag, String text, Throwable throwable)",N/A,void
io.fabric.sdk.android.services.concurrency.Task,Represents a Task to be processed,getError(),N/A,Throwable
io.fabric.sdk.android.services.concurrency.Task,Represents a Task to be processed,isFinished(),N/A,boolean
io.fabric.sdk.android.services.concurrency.Task,Represents a Task to be processed,setError(Throwable throwable),N/A,void
io.fabric.sdk.android.services.concurrency.Task,Represents a Task to be processed,setFinished(boolean finished),Marks Task as finished,void
io.fabric.sdk.android.services.concurrency.UnmetDependencyException,Used when a dependency is required but not met.,N/A,N/A,N/A
